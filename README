=====================================================================
Introduction
======================================================================

The Whiley programming language employs the extended static checking
to eliminate he errors at the compile time, and compiles the
high-level Whiley program into different kinds of implementations.
However, the C implementations that the Whiley compiler generates are
currently quite inefficient, due to always using unbounded integers,
unbounded data structures with frequent copying, etc. This project
aims to use the program analysis techniques to generate efficient
parallel implementations in C and OpenCL and to gain the speed-up
across heterogeneous platforms.


======================================================================
Installation
======================================================================

1. The Whiley Intermediate Language Interpreter (WyIL Interpreter)
----------------------------------------------------------------------
To play with WyIL interpreter, please Open Cygwin/terminal and follow
the below instructions.
$ git clone https://github.com/samminweng/WhileyOpenCL
$ cd WhileyOpenCL/
$ ant  
$ cd examples/
$ ./../bin/wyopcl sieve.whiley 100
or add the verbose option to print out the interpretation.
$ ./../bin/wyopcl -verbose sieve.whiley 100

Note that if you encounter the permission problem while running the
wyopcl shell script, use the below command:
$ chmod a+x ../bin/*

Or the interpreter can be verified with 616 test cases with the command:
$ ant report
The unit test results are summarized at 'report/html/index.html'. 
The current success rate is 94.48% (Failures: 17, Errors: 17, Skipped: 51).

2. Whiley-to-OpenCL translator
The Whiley-to-OpenCL translator is written in Java and aims to generate
C/OpenCL code and proof obligation. At this stage, we will use the prime
example as the main test case (perhaps we need more) to manually generate
its OpenCL code and produce the proof obligations in SMT syntax, which
allows us to make use of different SMT solvers (e.g. Z3). 

