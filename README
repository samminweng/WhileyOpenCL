============================================================================================
Introduction
============================================================================================

The Whiley programming language employs the extended static checking to eliminate the errors at the compile time, and compiles the high-level Whiley program into different kinds of implementations. However, the C implementations that the Whiley compiler generates are currently quite inefficient, due to always using unbounded integers, unbounded data structures with frequent copying, etc. This project aims to use the program analysis techniques to generate efficient parallel implementations in C and OpenCL and to gain the speed-up across heterogeneous platforms.

============================================================================================
Installation
============================================================================================

Please Open Cygwin/terminal and follow the below instructions.
$ git clone https://github.com/samminweng/WhileyOpenCL && cd WhileyOpenCL/ && ant

To update the code from GitHub, use the below commands:
$ git reset --hard HEAD && git clean -dfx && git pull

'git reset' resets the code base to the most recent commit.
'git clean -dfx' removes all the untracked files.
'git checkout -- <file>' undoes the changes of a file.

============================================================================================
Usage
============================================================================================

1. Whiley-to-OpenCL translator
The Whiley-to-OpenCL translator is written in Java and aims to generate C/OpenCL code and proof obligation. At this stage, we will use the prime example as the main test case (perhaps we need more) to manually generate its OpenCL code and produce the proof obligations in SMT syntax, which allows us to make use of different SMT solvers (e.g. Z3).
----------------------------------------------------------------------
1.1 Bound Analyzer
Bound analyzer aims to infer the bounds and check the bounds consistent with all constraints.
$ cd examples && ./../bin/wyopcl -bound naive whileloop.whiley
Or use the gradual widening strategy to get more precise bounds.
$ ./../bin/wyopcl -bound gradual whileloop.whiley

1.2 Pattern Matching and Pattern Transformation
Pattern matching aims to match patterns and transform the code of a specific function code. Currently, 'AppendArray' pattern can be transformed to 'ResizeArray' pattern.
$ cd examples && ./../bin/wyopcl -pattern compress lz77.whiley

1.3 Copy Elimination Analysis
Copy Elimination analysis aims to eliminate the un-necessary copies at the program.
$ cd examples && ./../bin/wyopcl -code -nocopy example.whiley

1.4 Deallocation Analysis
Deallocation analysis aims to add extra mallocs to release un-used memory at function exit.
$ cd examples && ./../bin/wyopcl -code -dealloc example.whiley

1.5 Code Generator
Code Generator aims to translate the Whiley program into C code. 
The code generator can work with both copy and deallocation analyses to produce the most efficient C code.
Note '-ea' option enables to generate C code with assertions. 
$ cd examples && ./../bin/wyopcl -code -nocopy -dealloc -ea example.whiley
Two external utility and runtime function C library must be copied to the same folder to finish the compilation
$ cp ../tests/code/Util.c ../tests/code/Util.h ../tests/code/WyRT.c ../tests/code/WyRT.h .
$ gcc example.c Util.c WyRT.c -o example.out && ./example.out


============================================================================================
Unit Testing
============================================================================================
1. Whiley-to-OpenCL translator
1.1 Bound Analyzer
The bound analyzer is tested with 5 Whiley programs. Use the below commands:
$ ant test-bound

1.2 Pattern Matching and Pattern Transformation
The pattern matching is tested with 2 Whiley programs. Use the below commands:
$ ant test-pattern

1.3 Copy Elimination
The copy elimination is tested with 7 Whiley programs. Use the below commands:
$ ant test-copy

1.3 Code Generator/Copy Elimination/Memory Deallocation
The code generator (with copy/deallocation analysers) is tested with 43 Whiley programs.
$ ant test-code
To detect the memory leaks of each test case, we use the below shell script:
$ cd tests/code
$ ./memorydetect.sh
All the execution results are output to 'memorylog.txt'

1.4 Model checking
Model checking is used to check the assumption at runtime with 722 test Whiley programs. 
$ ant test-modelchecking
To detect memory leaks and check if deallocation macro satisfies the assumption at runtime,
we use the below shell script:
$ cd tests/modelchecking
$ ./memorydetect.sh
All the execution results are output to 'memorylog.txt'