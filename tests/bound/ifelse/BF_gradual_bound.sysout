WARNING: version numbering unavailable
Parsed 1 source file(s). ....................................................... [78ms+1mb]
Typed 1 source file(s). ....................................................... [115ms+1mb]
Generated code for 1 source file(s). ........................................... [22ms+1mb]
[./ifelse.whiley] applied definite assignment check ................................. [2ms]
[./ifelse.whiley] applied module check .......................................... [2ms+1mb]
[./ifelse.whiley] applied loop variants ......................................... [1ms+1mb]
[./ifelse.whiley] applied coercion check ............................................ [1ms]
Whiley => Wyil: compiled 1 file(s) ............................................ [246ms-1mb]
f.0 [	const %2 = 10 : int]
f.1 [	ifge %0, %2 goto blklab1 : int]
f.2 [	const %3 = 1 : int]
f.3 [	return %3]
f.4 [	goto blklab2]
f.5 [.blklab1]
f.6 [	const %4 = 10 : int]
f.7 [	ifle %0, %4 goto blklab3 : int]
f.8 [	const %5 = 2 : int]
f.9 [	return %5]
f.10 [.blklab3]
f.11 [.blklab2]
f.12 [	const %6 = 0 : int]
f.13 [	return %6]
f.14 [	return]
main.0 [	const %5 = 1 : int]
main.1 [	invoke (%4) = (%5) ifelse:f : function(int)->(int)]
main.2 [	assign %1 = %4  : int]
main.3 [	assert]
main.4 [	fieldload %7 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.5 [	fieldload %8 = %7 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.6 [	indirectinvoke () = %8 (%1) : method(any)->()]
main.7 [	const %10 = 10 : int]
main.8 [	invoke (%9) = (%10) ifelse:f : function(int)->(int)]
main.9 [	assign %2 = %9  : int]
main.10 [	assert]
main.11 [	fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.12 [	fieldload %13 = %12 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.13 [	indirectinvoke () = %13 (%2) : method(any)->()]
main.14 [	const %15 = 11 : int]
main.15 [	invoke (%14) = (%15) ifelse:f : function(int)->(int)]
main.16 [	assign %3 = %14  : int]
main.17 [	assert]
main.18 [	fieldload %17 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.19 [	fieldload %18 = %17 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.20 [	indirectinvoke () = %18 (%3) : method(any)->()]
main.21 [	return]
###### Live analysis for f function. ######
Iteration 1
In:{[0, 4]}
blklab3 [ELSE] 
-------------------------------
l.0:ifle %0, %4 goto blklab3 : int
-------------------------------
Out:{[]}

In:{[0, 4]}
blklab3 [IF] 
-------------------------------
l.0:ifgt %0, %4 goto blklab3 : int
l.1:const %5 = 2 : int
-------------------------------
Out:{[5]}

In:{[0, 4]}
blklab3 [CONDITION] 
Out:{[0, 4]}

In:{[]}
blklab2 [BLOCK] 
-------------------------------
l.0:const %6 = 0 : int
-------------------------------
Out:{[6]}

In:{[0, 2]}
blklab1 [ELSE] 
-------------------------------
l.0:ifge %0, %2 goto blklab1 : int
l.1:const %4 = 10 : int
-------------------------------
Out:{[0, 4]}

In:{[0, 2]}
blklab1 [IF] 
-------------------------------
l.0:iflt %0, %2 goto blklab1 : int
l.1:const %3 = 1 : int
-------------------------------
Out:{[3]}

In:{[0, 2]}
blklab1 [CONDITION] 
Out:{[0, 2]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %2 = 10 : int
-------------------------------
Out:{[0, 2]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live analysis for f function. ######
Iteration 2
In:{[0, 4]}
blklab3 [ELSE] 
-------------------------------
l.0:ifle %0, %4 goto blklab3 : int
-------------------------------
Out:{[]}

In:{[0, 4]}
blklab3 [IF] 
-------------------------------
l.0:ifgt %0, %4 goto blklab3 : int
l.1:const %5 = 2 : int
-------------------------------
Out:{[5]}

In:{[0, 4]}
blklab3 [CONDITION] 
Out:{[0, 4]}

In:{[]}
blklab2 [BLOCK] 
-------------------------------
l.0:const %6 = 0 : int
-------------------------------
Out:{[6]}

In:{[0, 2]}
blklab1 [ELSE] 
-------------------------------
l.0:ifge %0, %2 goto blklab1 : int
l.1:const %4 = 10 : int
-------------------------------
Out:{[0, 4]}

In:{[0, 2]}
blklab1 [IF] 
-------------------------------
l.0:iflt %0, %2 goto blklab1 : int
l.1:const %3 = 1 : int
-------------------------------
Out:{[3]}

In:{[0, 2]}
blklab1 [CONDITION] 
Out:{[0, 2]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %2 = 10 : int
-------------------------------
Out:{[0, 2]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live variables for f function. ######
In:{x}
entry [ENTRY] 
Out:{x}

In:{x}
code [BLOCK] 
-------------------------------
l.0:const %2 = 10 : int
-------------------------------
Out:{x, _2}

In:{x, _2}
blklab1 [CONDITION] 
Out:{x, _2}

In:{x, _2}
blklab1 [IF] 
-------------------------------
l.0:iflt %0, %2 goto blklab1 : int
l.1:const %3 = 1 : int
-------------------------------
Out:{_3}

In:{x, _2}
blklab1 [ELSE] 
-------------------------------
l.0:ifge %0, %2 goto blklab1 : int
l.1:const %4 = 10 : int
-------------------------------
Out:{x, _4}

In:{_3}
return_3 [RETURN] 
-------------------------------
l.0:return %3
-------------------------------
Out:{_3}

In:{}
blklab2 [BLOCK] 
-------------------------------
l.0:const %6 = 0 : int
-------------------------------
Out:{_6}

In:{x, _4}
blklab3 [CONDITION] 
Out:{x, _4}

In:{x, _4}
blklab3 [IF] 
-------------------------------
l.0:ifgt %0, %4 goto blklab3 : int
l.1:const %5 = 2 : int
-------------------------------
Out:{_5}

In:{x, _4}
blklab3 [ELSE] 
-------------------------------
l.0:ifle %0, %4 goto blklab3 : int
-------------------------------
Out:{}

In:{_5}
return_5 [RETURN] 
-------------------------------
l.0:return %5
-------------------------------
Out:{_5}

In:{_6}
return_6 [RETURN] 
-------------------------------
l.0:return %6
-------------------------------
Out:{_6}

In:{}
exit [EXIT] 
Out:{}

###### Live analysis for main function. ######
Iteration 1
In:{[0, 14]}
f16 [BLOCK] 
-------------------------------
l.0:assign %3 = %14  : int
l.1:fieldload %17 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %18 = %17 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %18 (%3) : method(any)->()
-------------------------------
Out:{[]}

In:{[0, 15]}
f16 [INVOKE] 
-------------------------------
l.0:invoke (%14) = (%15) ifelse:f : function(int)->(int)
-------------------------------
Out:{[0, 14]}

In:{[0, 9]}
f9 [BLOCK] 
-------------------------------
l.0:assign %2 = %9  : int
l.1:fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %13 = %12 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %13 (%2) : method(any)->()
l.4:const %15 = 11 : int
-------------------------------
Out:{[0, 15]}

In:{[0, 10]}
f9 [INVOKE] 
-------------------------------
l.0:invoke (%9) = (%10) ifelse:f : function(int)->(int)
-------------------------------
Out:{[0, 9]}

In:{[0, 4]}
f2 [BLOCK] 
-------------------------------
l.0:assign %1 = %4  : int
l.1:fieldload %7 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %8 = %7 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %8 (%1) : method(any)->()
l.4:const %10 = 10 : int
-------------------------------
Out:{[0, 10]}

In:{[0, 5]}
f2 [INVOKE] 
-------------------------------
l.0:invoke (%4) = (%5) ifelse:f : function(int)->(int)
-------------------------------
Out:{[0, 4]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %5 = 1 : int
-------------------------------
Out:{[0, 5]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live analysis for main function. ######
Iteration 2
In:{[0, 14]}
f16 [BLOCK] 
-------------------------------
l.0:assign %3 = %14  : int
l.1:fieldload %17 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %18 = %17 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %18 (%3) : method(any)->()
-------------------------------
Out:{[]}

In:{[0, 15]}
f16 [INVOKE] 
-------------------------------
l.0:invoke (%14) = (%15) ifelse:f : function(int)->(int)
-------------------------------
Out:{[0, 14]}

In:{[0, 9]}
f9 [BLOCK] 
-------------------------------
l.0:assign %2 = %9  : int
l.1:fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %13 = %12 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %13 (%2) : method(any)->()
l.4:const %15 = 11 : int
-------------------------------
Out:{[0, 15]}

In:{[0, 10]}
f9 [INVOKE] 
-------------------------------
l.0:invoke (%9) = (%10) ifelse:f : function(int)->(int)
-------------------------------
Out:{[0, 9]}

In:{[0, 4]}
f2 [BLOCK] 
-------------------------------
l.0:assign %1 = %4  : int
l.1:fieldload %7 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %8 = %7 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %8 (%1) : method(any)->()
l.4:const %10 = 10 : int
-------------------------------
Out:{[0, 10]}

In:{[0, 5]}
f2 [INVOKE] 
-------------------------------
l.0:invoke (%4) = (%5) ifelse:f : function(int)->(int)
-------------------------------
Out:{[0, 4]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %5 = 1 : int
-------------------------------
Out:{[0, 5]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live variables for main function. ######
In:{sys}
entry [ENTRY] 
Out:{sys}

In:{sys}
code [BLOCK] 
-------------------------------
l.0:const %5 = 1 : int
-------------------------------
Out:{sys, _5}

In:{sys, _5}
f2 [INVOKE] 
-------------------------------
l.0:invoke (%4) = (%5) ifelse:f : function(int)->(int)
-------------------------------
Out:{sys, _4}

In:{sys, _4}
f2 [BLOCK] 
-------------------------------
l.0:assign %1 = %4  : int
l.1:fieldload %7 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %8 = %7 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %8 (%1) : method(any)->()
l.4:const %10 = 10 : int
-------------------------------
Out:{sys, _10}

In:{sys, _10}
f9 [INVOKE] 
-------------------------------
l.0:invoke (%9) = (%10) ifelse:f : function(int)->(int)
-------------------------------
Out:{sys, _9}

In:{sys, _9}
f9 [BLOCK] 
-------------------------------
l.0:assign %2 = %9  : int
l.1:fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %13 = %12 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %13 (%2) : method(any)->()
l.4:const %15 = 11 : int
-------------------------------
Out:{sys, _15}

In:{sys, _15}
f16 [INVOKE] 
-------------------------------
l.0:invoke (%14) = (%15) ifelse:f : function(int)->(int)
-------------------------------
Out:{sys, _14}

In:{sys, _14}
f16 [BLOCK] 
-------------------------------
l.0:assign %3 = %14  : int
l.1:fieldload %17 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %18 = %17 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %18 (%3) : method(any)->()
-------------------------------
Out:{}

In:{}
exit [EXIT] 
Out:{}

=== Bound Analysis on main function ===
main.0 [	const %5 = 1 : int]
main.1 [	invoke (%4) = (%5) ifelse:f : function(int)->(int)]
### Iteration 0 ### 
'2' blocks in queue : [ENTRY][BLOCK]
entry [ENTRY] 
Vars []
DeadVars []
Constraints []

IsReachable=true
isChanged=false
### Iteration 1 ### 
'1' blocks in queue : [BLOCK]
code [BLOCK] 
-------------------------------
0:const %5 = 1 : int
-------------------------------
Vars [_5]
DeadVars []
Constraints [_5:=1]

	domain(_5)	= [1..1]	
IsReachable=true
isChanged=true
=================================

Bound Analysis of 'main' function:
	domain(_5)	=[1..1]
Consistency=true

=================================
f.0 [	const %2 = 10 : int]
f.1 [	ifge %0, %2 goto blklab1 : int]
f.2 [	const %3 = 1 : int]
f.3 [	return %3]
f.4 [	goto blklab2]
f.5 [.blklab1]
f.6 [	const %4 = 10 : int]
f.7 [	ifle %0, %4 goto blklab3 : int]
f.8 [	const %5 = 2 : int]
f.9 [	return %5]
f.10 [.blklab3]
f.11 [.blklab2]
f.12 [	const %6 = 0 : int]
f.13 [	return %6]
f.14 [	return]
### Iteration 0 ### 
'2' blocks in queue : [ENTRY][BLOCK]
entry [ENTRY] 
Vars [_0]
DeadVars []
Constraints [_0:=[1..1]]

	domain(_0)	= [1..1]	
IsReachable=true
isChanged=true
### Iteration 1 ### 
'1' blocks in queue : [BLOCK]
code [BLOCK] 
-------------------------------
0:const %2 = 10 : int
-------------------------------
Vars [_2, _0]
DeadVars []
Constraints [_2:=10, _0:=[1..1]]

	domain(_0)	= [1..1]	
	domain(_2)	= [10..10]	
IsReachable=true
isChanged=true
### Iteration 2 ### 
'2' blocks in queue : [IF][ELSE]
blklab1 [IF] 
-------------------------------
0:const %3 = 1 : int
-------------------------------
Vars [_0, _2, _3]
DeadVars [_0, _2]
Constraints [_0<_2, _3:=1]

	domain(_0)	= [1..1]	
	domain(_2)	= [10..10]	
	domain(_3)	= [1..1]	
IsReachable=true
isChanged=true
### Iteration 3 ### 
'2' blocks in queue : [ELSE][RETURN]
blklab1 [ELSE] 
-------------------------------
0:ifge %0, %2 goto blklab1 : int
1:const %4 = 10 : int
-------------------------------
Vars [_0, _2, _4]
DeadVars [_2]
Constraints [_0>=_2, _4:=10]

	domain(_0)	= [empty..empty]	
	domain(_2)	= [empty..empty]	
	domain(_4)	= [10..10]	
IsReachable=false
isChanged=false
### Iteration 4 ### 
'1' blocks in queue : [RETURN]
return_3 [RETURN] 
-------------------------------
0:return %3
-------------------------------
Vars [_3]
DeadVars []
Constraints [return:=_3]

	domain(_3)	= [1..1]	
	domain(return)	= [1..1]	
IsReachable=true
isChanged=true
=================================

Bound Analysis of 'f' function:
	domain(x)	=[1..1]
	domain(_2)	=[10..10]
	domain(_3)	=[1..1]
	domain(return)	=[1..1]
Consistency=true

=================================
main.2 [	assign %1 = %4  : int]
main.3 [	assert]
main.4 [	fieldload %7 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.5 [	fieldload %8 = %7 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.6 [	indirectinvoke () = %8 (%1) : method(any)->()]
main.7 [	const %10 = 10 : int]
main.8 [	invoke (%9) = (%10) ifelse:f : function(int)->(int)]
### Iteration 0 ### 
'2' blocks in queue : [ENTRY][BLOCK]
entry [ENTRY] 
Vars []
DeadVars []
Constraints []

IsReachable=true
isChanged=false
### Iteration 1 ### 
'1' blocks in queue : [BLOCK]
code [BLOCK] 
-------------------------------
0:const %5 = 1 : int
1:assign %1 = %4  : int
2:const %10 = 10 : int
-------------------------------
Vars [_5, _4, _1, _10]
DeadVars [_4, _1, _10]
Constraints [_5:=1, _4:=[1..1], _1:=_4, _10:=10]

	domain(_1)	= [1..1]	
	domain(_10)	= [10..10]	
	domain(_4)	= [1..1]	
	domain(_5)	= [1..1]	
IsReachable=true
isChanged=true
=================================

Bound Analysis of 'main' function:
	domain(a)	=[1..1]
	domain(_10)	=[10..10]
	domain(_4)	=[1..1]
	domain(_5)	=[1..1]
Consistency=true

=================================
### Iteration 0 ### 
'2' blocks in queue : [ENTRY][BLOCK]
entry [ENTRY] 
Vars [_0]
DeadVars []
Constraints [_0:=[10..10]]

	domain(_0)	= [10..10]	
IsReachable=true
isChanged=true
### Iteration 1 ### 
'1' blocks in queue : [BLOCK]
code [BLOCK] 
-------------------------------
0:const %2 = 10 : int
-------------------------------
Vars [_2, _0]
DeadVars []
Constraints [_2:=10, _0:=[10..10]]

	domain(_0)	= [10..10]	
	domain(_2)	= [10..10]	
IsReachable=true
isChanged=true
### Iteration 2 ### 
'2' blocks in queue : [IF][ELSE]
blklab1 [IF] 
-------------------------------
0:const %3 = 1 : int
-------------------------------
Vars [_0, _2, _3]
DeadVars [_0, _2]
Constraints [_0<_2, _3:=1]

	domain(_0)	= [empty..empty]	
	domain(_2)	= [empty..empty]	
	domain(_3)	= [1..1]	
IsReachable=false
isChanged=false
### Iteration 3 ### 
'1' blocks in queue : [ELSE]
blklab1 [ELSE] 
-------------------------------
0:ifge %0, %2 goto blklab1 : int
1:const %4 = 10 : int
-------------------------------
Vars [_0, _2, _4]
DeadVars [_2]
Constraints [_0>=_2, _4:=10]

	domain(_0)	= [10..10]	
	domain(_2)	= [10..10]	
	domain(_4)	= [10..10]	
IsReachable=true
isChanged=true
### Iteration 4 ### 
'2' blocks in queue : [IF][ELSE]
blklab3 [IF] 
-------------------------------
0:const %5 = 2 : int
-------------------------------
Vars [_0, _4, _5]
DeadVars [_0, _4]
Constraints [_0>_4, _5:=2]

	domain(_0)	= [empty..empty]	
	domain(_4)	= [empty..empty]	
	domain(_5)	= [2..2]	
IsReachable=false
isChanged=false
### Iteration 5 ### 
'1' blocks in queue : [ELSE]
blklab3 [ELSE] 
-------------------------------
0:ifle %0, %4 goto blklab3 : int
-------------------------------
Vars [_0, _4]
DeadVars [_0, _4]
Constraints [_0<=_4]

	domain(_0)	= [10..10]	
	domain(_4)	= [10..10]	
IsReachable=true
isChanged=true
### Iteration 6 ### 
'1' blocks in queue : [BLOCK]
blklab2 [BLOCK] 
-------------------------------
0:const %6 = 0 : int
-------------------------------
Vars [_6]
DeadVars []
Constraints [_6:=0]

	domain(_6)	= [0..0]	
IsReachable=true
isChanged=true
### Iteration 7 ### 
'1' blocks in queue : [RETURN]
return_6 [RETURN] 
-------------------------------
0:return %6
-------------------------------
Vars [_6]
DeadVars []
Constraints [return:=_6]

	domain(_6)	= [0..0]	
	domain(return)	= [0..0]	
IsReachable=true
isChanged=true
=================================

Bound Analysis of 'f' function:
	domain(x)	=[10..10]
	domain(_2)	=[10..10]
	domain(_4)	=[10..10]
	domain(_6)	=[0..0]
	domain(return)	=[0..0]
Consistency=true

=================================
main.9 [	assign %2 = %9  : int]
main.10 [	assert]
main.11 [	fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.12 [	fieldload %13 = %12 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.13 [	indirectinvoke () = %13 (%2) : method(any)->()]
main.14 [	const %15 = 11 : int]
main.15 [	invoke (%14) = (%15) ifelse:f : function(int)->(int)]
### Iteration 0 ### 
'2' blocks in queue : [ENTRY][BLOCK]
entry [ENTRY] 
Vars []
DeadVars []
Constraints []

IsReachable=true
isChanged=false
### Iteration 1 ### 
'1' blocks in queue : [BLOCK]
code [BLOCK] 
-------------------------------
0:const %5 = 1 : int
1:assign %1 = %4  : int
2:const %10 = 10 : int
3:assign %2 = %9  : int
4:const %15 = 11 : int
-------------------------------
Vars [_5, _4, _1, _10, _9, _2, _15]
DeadVars [_4, _1, _10, _9, _2, _15]
Constraints [_5:=1, _4:=[1..1], _1:=_4, _10:=10, _9:=[0..0], _2:=_9, _15:=11]

	domain(_1)	= [1..1]	
	domain(_10)	= [10..10]	
	domain(_15)	= [11..11]	
	domain(_2)	= [0..0]	
	domain(_4)	= [1..1]	
	domain(_5)	= [1..1]	
	domain(_9)	= [0..0]	
IsReachable=true
isChanged=true
=================================

Bound Analysis of 'main' function:
	domain(a)	=[1..1]
	domain(_10)	=[10..10]
	domain(_15)	=[11..11]
	domain(b)	=[0..0]
	domain(_4)	=[1..1]
	domain(_5)	=[1..1]
	domain(_9)	=[0..0]
Consistency=true

=================================
### Iteration 0 ### 
'2' blocks in queue : [ENTRY][BLOCK]
entry [ENTRY] 
Vars [_0]
DeadVars []
Constraints [_0:=[11..11]]

	domain(_0)	= [11..11]	
IsReachable=true
isChanged=true
### Iteration 1 ### 
'1' blocks in queue : [BLOCK]
code [BLOCK] 
-------------------------------
0:const %2 = 10 : int
-------------------------------
Vars [_2, _0]
DeadVars []
Constraints [_2:=10, _0:=[11..11]]

	domain(_0)	= [11..11]	
	domain(_2)	= [10..10]	
IsReachable=true
isChanged=true
### Iteration 2 ### 
'2' blocks in queue : [IF][ELSE]
blklab1 [IF] 
-------------------------------
0:const %3 = 1 : int
-------------------------------
Vars [_0, _2, _3]
DeadVars [_0, _2]
Constraints [_0<_2, _3:=1]

	domain(_0)	= [empty..empty]	
	domain(_2)	= [empty..empty]	
	domain(_3)	= [1..1]	
IsReachable=false
isChanged=false
### Iteration 3 ### 
'1' blocks in queue : [ELSE]
blklab1 [ELSE] 
-------------------------------
0:ifge %0, %2 goto blklab1 : int
1:const %4 = 10 : int
-------------------------------
Vars [_0, _2, _4]
DeadVars [_2]
Constraints [_0>=_2, _4:=10]

	domain(_0)	= [11..11]	
	domain(_2)	= [10..10]	
	domain(_4)	= [10..10]	
IsReachable=true
isChanged=true
### Iteration 4 ### 
'2' blocks in queue : [IF][ELSE]
blklab3 [IF] 
-------------------------------
0:const %5 = 2 : int
-------------------------------
Vars [_0, _4, _5]
DeadVars [_0, _4]
Constraints [_0>_4, _5:=2]

	domain(_0)	= [11..11]	
	domain(_4)	= [10..10]	
	domain(_5)	= [2..2]	
IsReachable=true
isChanged=true
### Iteration 5 ### 
'2' blocks in queue : [ELSE][RETURN]
blklab3 [ELSE] 
-------------------------------
0:ifle %0, %4 goto blklab3 : int
-------------------------------
Vars [_0, _4]
DeadVars [_0, _4]
Constraints [_0<=_4]

	domain(_0)	= [empty..empty]	
	domain(_4)	= [empty..empty]	
IsReachable=false
isChanged=false
### Iteration 6 ### 
'1' blocks in queue : [RETURN]
return_5 [RETURN] 
-------------------------------
0:return %5
-------------------------------
Vars [_5]
DeadVars []
Constraints [return:=_5]

	domain(_5)	= [2..2]	
	domain(return)	= [2..2]	
IsReachable=true
isChanged=true
=================================

Bound Analysis of 'f' function:
	domain(x)	=[11..11]
	domain(_2)	=[10..10]
	domain(_4)	=[10..10]
	domain(_5)	=[2..2]
	domain(return)	=[2..2]
Consistency=true

=================================
main.16 [	assign %3 = %14  : int]
main.17 [	assert]
main.18 [	fieldload %17 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.19 [	fieldload %18 = %17 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.20 [	indirectinvoke () = %18 (%3) : method(any)->()]
main.21 [	return]
### Iteration 0 ### 
'2' blocks in queue : [ENTRY][BLOCK]
entry [ENTRY] 
Vars []
DeadVars []
Constraints []

IsReachable=true
isChanged=false
### Iteration 1 ### 
'1' blocks in queue : [BLOCK]
code [BLOCK] 
-------------------------------
0:const %5 = 1 : int
1:assign %1 = %4  : int
2:const %10 = 10 : int
3:assign %2 = %9  : int
4:const %15 = 11 : int
5:assign %3 = %14  : int
-------------------------------
Vars [_5, _4, _1, _10, _9, _2, _15, _14, _3]
DeadVars [_4, _1, _10, _9, _2, _15, _14, _3]
Constraints [_5:=1, _4:=[1..1], _1:=_4, _10:=10, _9:=[0..0], _2:=_9, _15:=11, _14:=[2..2], _3:=_14]

	domain(_1)	= [1..1]	
	domain(_10)	= [10..10]	
	domain(_14)	= [2..2]	
	domain(_15)	= [11..11]	
	domain(_2)	= [0..0]	
	domain(_3)	= [2..2]	
	domain(_4)	= [1..1]	
	domain(_5)	= [1..1]	
	domain(_9)	= [0..0]	
IsReachable=true
isChanged=true
=================================

Bound Analysis of 'main' function:
	domain(a)	=[1..1]
	domain(_10)	=[10..10]
	domain(_14)	=[2..2]
	domain(_15)	=[11..11]
	domain(b)	=[0..0]
	domain(c)	=[2..2]
	domain(_4)	=[1..1]
	domain(_5)	=[1..1]
	domain(_9)	=[0..0]
Consistency=true

=================================

Bound analysis completed. File: ifelse
