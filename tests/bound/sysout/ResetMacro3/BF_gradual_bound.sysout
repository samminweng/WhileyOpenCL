WARNING: version numbering unavailable
func.0 [	const %4 = 0 : int]
func.1 [	const %5 = 3 : int]
func.2 [	arraygen %6 = [4; 5] : int[]]
func.3 [	assign %3 = %6  : int[]]
func.4 [	const %7 = 10 : int]
func.5 [	ifle %1, %7 goto blklab0 : int]
func.6 [	const %8 = 0 : int]
func.7 [	update %0[%8] = %1 : int[] -> int[]]
func.8 [	return %0]
func.9 [	goto blklab1]
func.10 [.blklab0]
func.11 [	return %3]
func.12 [.blklab1]
func.13 [	return]
main.0 [	const %4 = 2 : int]
main.1 [	const %5 = 3 : int]
main.2 [	arraygen %6 = [4; 5] : int[]]
main.3 [	assign %1 = %6  : int[]]
main.4 [	const %7 = 11 : int]
main.5 [	assign %2 = %7  : int]
main.6 [	invoke (%8) = (%1, %2) ResetMacro3:func : function(int[],int)->(int[])]
main.7 [	assign %3 = %8  : int[]]
main.8 [	assign %1 = %3  : int[]]
main.9 [	assert]
main.10 [	fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.11 [	fieldload %13 = %12 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.12 [	const %14 = [120,91,48,93,32,61,32] : int[]]
main.13 [	indirectinvoke () = %13 (%14) : method(int[])->()]
main.14 [	fieldload %15 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.15 [	fieldload %16 = %15 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.16 [	const %17 = 0 : int]
main.17 [	indexof %18 = %1, %17 : int[]]
main.18 [	indirectinvoke () = %16 (%18) : method(any)->()]
main.19 [	return]
###### Live analysis for func function. ######
Iteration 1
In:{[]}
blklab1 [BLOCK] 
Out:{[]}

In:{[1, 3, 7]}
blklab0 [ELSE] 
-------------------------------
l.0:ifle %1, %7 goto blklab0 : int
-------------------------------
Out:{[3]}

In:{[0, 1, 7]}
blklab0 [IF] 
-------------------------------
l.0:ifgt %1, %7 goto blklab0 : int
l.1:const %8 = 0 : int
l.2:update %0[%8] = %1 : int[] -> int[]
-------------------------------
Out:{[0]}

In:{[0, 1, 3, 7]}
blklab0 [CONDITION] 
Out:{[0, 1, 3, 7]}

In:{[0, 1]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 3 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %3 = %6  : int[]
l.4:const %7 = 10 : int
-------------------------------
Out:{[0, 1, 3, 7]}

In:{[0, 1]}
entry [ENTRY] 
Out:{[0, 1]}

###### Live analysis for func function. ######
Iteration 2
In:{[]}
blklab1 [BLOCK] 
Out:{[]}

In:{[1, 3, 7]}
blklab0 [ELSE] 
-------------------------------
l.0:ifle %1, %7 goto blklab0 : int
-------------------------------
Out:{[3]}

In:{[0, 1, 7]}
blklab0 [IF] 
-------------------------------
l.0:ifgt %1, %7 goto blklab0 : int
l.1:const %8 = 0 : int
l.2:update %0[%8] = %1 : int[] -> int[]
-------------------------------
Out:{[0]}

In:{[0, 1, 3, 7]}
blklab0 [CONDITION] 
Out:{[0, 1, 3, 7]}

In:{[0, 1]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 3 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %3 = %6  : int[]
l.4:const %7 = 10 : int
-------------------------------
Out:{[0, 1, 3, 7]}

In:{[0, 1]}
entry [ENTRY] 
Out:{[0, 1]}

###### Live variables for func function. ######
In:{x, num}
entry [ENTRY] 
Out:{x, num}

In:{x, num}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 3 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %3 = %6  : int[]
l.4:const %7 = 10 : int
-------------------------------
Out:{x, num, a, _7}

In:{x, num, a, _7}
blklab0 [CONDITION] 
Out:{x, num, a, _7}

In:{x, num, _7}
blklab0 [IF] 
-------------------------------
l.0:ifgt %1, %7 goto blklab0 : int
l.1:const %8 = 0 : int
l.2:update %0[%8] = %1 : int[] -> int[]
-------------------------------
Out:{x}

In:{num, a, _7}
blklab0 [ELSE] 
-------------------------------
l.0:ifle %1, %7 goto blklab0 : int
-------------------------------
Out:{a}

In:{x}
return_0 [RETURN] 
-------------------------------
l.0:return %0
-------------------------------
Out:{x}

In:{}
blklab1 [BLOCK] 
Out:{}

In:{a}
return_3 [RETURN] 
-------------------------------
l.0:return %3
-------------------------------
Out:{a}

In:{}
exit [EXIT] 
Out:{}

###### Live analysis for main function. ######
Iteration 1
In:{[0, 8]}
func7 [BLOCK] 
-------------------------------
l.0:assign %3 = %8  : int[]
l.1:assign %1 = %3  : int[]
l.2:fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.3:fieldload %13 = %12 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.4:const %14 = [120,91,48,93,32,61,32] : int[]
l.5:indirectinvoke () = %13 (%14) : method(int[])->()
l.6:fieldload %15 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.7:fieldload %16 = %15 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.8:const %17 = 0 : int
l.9:indexof %18 = %1, %17 : int[]
l.10:indirectinvoke () = %16 (%18) : method(any)->()
-------------------------------
Out:{[]}

In:{[0, 1, 2]}
func7 [INVOKE] 
-------------------------------
l.0:invoke (%8) = (%1, %2) ResetMacro3:func : function(int[],int)->(int[])
-------------------------------
Out:{[0, 8]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 2 : int
l.1:const %5 = 3 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %1 = %6  : int[]
l.4:const %7 = 11 : int
l.5:assign %2 = %7  : int
-------------------------------
Out:{[0, 1, 2]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live analysis for main function. ######
Iteration 2
In:{[0, 8]}
func7 [BLOCK] 
-------------------------------
l.0:assign %3 = %8  : int[]
l.1:assign %1 = %3  : int[]
l.2:fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.3:fieldload %13 = %12 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.4:const %14 = [120,91,48,93,32,61,32] : int[]
l.5:indirectinvoke () = %13 (%14) : method(int[])->()
l.6:fieldload %15 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.7:fieldload %16 = %15 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.8:const %17 = 0 : int
l.9:indexof %18 = %1, %17 : int[]
l.10:indirectinvoke () = %16 (%18) : method(any)->()
-------------------------------
Out:{[]}

In:{[0, 1, 2]}
func7 [INVOKE] 
-------------------------------
l.0:invoke (%8) = (%1, %2) ResetMacro3:func : function(int[],int)->(int[])
-------------------------------
Out:{[0, 8]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 2 : int
l.1:const %5 = 3 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %1 = %6  : int[]
l.4:const %7 = 11 : int
l.5:assign %2 = %7  : int
-------------------------------
Out:{[0, 1, 2]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live variables for main function. ######
In:{sys}
entry [ENTRY] 
Out:{sys}

In:{sys}
code [BLOCK] 
-------------------------------
l.0:const %4 = 2 : int
l.1:const %5 = 3 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %1 = %6  : int[]
l.4:const %7 = 11 : int
l.5:assign %2 = %7  : int
-------------------------------
Out:{sys, x, num}

In:{sys, x, num}
func7 [INVOKE] 
-------------------------------
l.0:invoke (%8) = (%1, %2) ResetMacro3:func : function(int[],int)->(int[])
-------------------------------
Out:{sys, _8}

In:{sys, _8}
func7 [BLOCK] 
-------------------------------
l.0:assign %3 = %8  : int[]
l.1:assign %1 = %3  : int[]
l.2:fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.3:fieldload %13 = %12 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.4:const %14 = [120,91,48,93,32,61,32] : int[]
l.5:indirectinvoke () = %13 (%14) : method(int[])->()
l.6:fieldload %15 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.7:fieldload %16 = %15 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.8:const %17 = 0 : int
l.9:indexof %18 = %1, %17 : int[]
l.10:indirectinvoke () = %16 (%18) : method(any)->()
-------------------------------
Out:{}

In:{}
exit [EXIT] 
Out:{}

=== Bound Analysis on main function ===
=================================

Bound Analysis of 'main' function:
	domain(x)	=[2..2]
	domain(x_size)	=[3..3]
	domain(num)	=[11..11]
	domain(_4)	=[2..2]
	domain(_5)	=[3..3]
	domain(_6)	=[2..2]
	domain(_6_size)	=[3..3]
	domain(_7)	=[11..11]
Consistency=true

=================================
=================================

Bound Analysis of 'func' function:
	domain(x)	=[2..11]
	domain(x_size)	=[3..3]
	domain(num)	=[11..11]
	domain(a)	=[0..0]
	domain(a_size)	=[3..3]
	domain(_4)	=[0..0]
	domain(_5)	=[3..3]
	domain(_6)	=[0..0]
	domain(_6_size)	=[3..3]
	domain(_7)	=[10..10]
	domain(_8)	=[0..0]
	domain(return)	=[2..11]
	domain(return_size)	=[3..3]
Consistency=true

=================================
=================================

Bound Analysis of 'main' function:
	domain(x)	=[2..11]
	domain(_14)	=[32..120]
	domain(_14_size)	=[7..7]
	domain(_17)	=[0..0]
	domain(x_size)	=[3..3]
	domain(num)	=[11..11]
	domain(tmp)	=[2..11]
	domain(tmp_size)	=[3..3]
	domain(_4)	=[2..2]
	domain(_5)	=[3..3]
	domain(_6)	=[2..2]
	domain(_6_size)	=[3..3]
	domain(_7)	=[11..11]
	domain(_8)	=[2..11]
	domain(_8_size)	=[3..3]
Consistency=true

=================================

Bound analysis completed. File: ResetMacro3
