root->Cash
root->Cash
root->total
root->contained
root->add
root->subtract
root->calculateChange
root->toString
root->buy
root->main
###### Live variables for Cash function. ######
In:{}
entry [ENTRY] 
Out:{}

In:{}
code [BLOCK] 
-------------------------------
l.0:const %1 = 0 : int
l.1:const %2 = 0 : int
l.2:const %3 = 0 : int
l.3:const %4 = 0 : int
l.4:const %5 = 0 : int
l.5:const %6 = 0 : int
l.6:const %7 = 0 : int
l.7:const %8 = 0 : int
l.8:newlist %9 = (%1, %2, %3, %4, %5, %6, %7, %8) : int[]
-------------------------------
Out:{_9}

In:{_9}
return_9 [RETURN] 
-------------------------------
l.0:return %9
-------------------------------
Out:{_9}

In:{}
exit [EXIT] 
Out:{}

###### Live variables for Cash function. ######
In:{coins}
entry [ENTRY] 
Out:{coins}

In:{coins}
code [BLOCK] 
-------------------------------
l.0:const %5 = 0 : int
l.1:const %6 = 0 : int
l.2:const %7 = 0 : int
l.3:const %8 = 0 : int
l.4:const %9 = 0 : int
l.5:const %10 = 0 : int
l.6:const %11 = 0 : int
l.7:const %12 = 0 : int
l.8:newlist %13 = (%5, %6, %7, %8, %9, %10, %11, %12) : int[]
l.9:assign %2 = %13  : int[]
l.10:const %14 = 0 : int
l.11:assign %3 = %14  : int
-------------------------------
Out:{coins, cash, i}

In:{coins, cash, i}
blklab4 [LOOP_HEADER] 
Out:{coins, cash, i}

In:{coins, cash, i}
blklab4 [LOOP_BODY] 
-------------------------------
l.0:invariant
l.1:lengthof %23 = %0 : int[]
l.2:ifge %3, %23 goto blklab4 : int
l.3:indexof %24 = %0, %3 : int[]
l.4:assign %4 = %24  : int
l.5:indexof %25 = %2, %4 : int[]
l.6:const %26 = 1 : int
l.7:add %27 = %25, %26 : int
-------------------------------
Out:{coins, cash, i}

In:{cash}
blklab4 [LOOP_EXIT] 
Out:{cash}

In:{coins, cash, i}
Update22 [UPDATE] 
-------------------------------
l.0:update %2[%4] = %27 : int[] -> int[]
-------------------------------
Out:{coins, cash, i}

In:{coins, cash, i}
Update22 [BLOCK] 
-------------------------------
l.0:const %28 = 1 : int
l.1:add %29 = %3, %28 : int
l.2:assign %3 = %29  : int
-------------------------------
Out:{coins, cash, i}

In:{coins, cash, i}
blklab5 [BLOCK] 
Out:{coins, cash, i}

In:{cash}
return_2 [RETURN] 
-------------------------------
l.0:return %2
-------------------------------
Out:{cash}

In:{}
exit [EXIT] 
Out:{}

###### Live variables for total function. ######
In:{c}
entry [ENTRY] 
Out:{c}

In:{c}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:assign %2 = %4  : int
l.2:const %5 = 0 : int
l.3:assign %3 = %5  : int
-------------------------------
Out:{c, r, i}

In:{c, r, i}
blklab9 [LOOP_HEADER] 
Out:{c, r, i}

In:{c, r, i}
blklab9 [LOOP_BODY] 
-------------------------------
l.0:lengthof %6 = %0 : int[]
l.1:ifge %3, %6 goto blklab9 : int
l.2:const %7 = [1,5,10,20,50,100,500,1000] : int[]
l.3:indexof %8 = %7, %3 : int[]
l.4:indexof %9 = %0, %3 : int[]
l.5:mul %10 = %8, %9 : int
l.6:add %11 = %2, %10 : int
l.7:assign %2 = %11  : int
l.8:const %12 = 1 : int
l.9:add %13 = %3, %12 : int
l.10:assign %3 = %13  : int
-------------------------------
Out:{c, r, i}

In:{r}
blklab9 [LOOP_EXIT] 
Out:{r}

In:{c, r, i}
blklab10 [BLOCK] 
Out:{c, r, i}

In:{r}
return_2 [RETURN] 
-------------------------------
l.0:return %2
-------------------------------
Out:{r}

In:{}
exit [EXIT] 
Out:{}

###### Live variables for contained function. ######
In:{first, second}
entry [ENTRY] 
Out:{first, second}

In:{first, second}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:assign %3 = %4  : int
-------------------------------
Out:{first, second, i}

In:{first, second, i}
blklab11 [LOOP_HEADER] 
Out:{first, second, i}

In:{first, second, i}
blklab11 [LOOP_BODY] 
-------------------------------
l.0:lengthof %5 = %0 : int[]
l.1:ifge %3, %5 goto blklab11 : int
l.2:indexof %6 = %0, %3 : int[]
l.3:indexof %7 = %1, %3 : int[]
-------------------------------
Out:{first, second, i, _6, _7}

In:{}
blklab11 [LOOP_EXIT] 
-------------------------------
l.0:const %11 = true : bool
-------------------------------
Out:{_11}

In:{first, second, i, _6, _7}
blklab13 [CONDITION] 
Out:{first, second, i, _6, _7}

In:{_6, _7}
blklab13 [IF] 
-------------------------------
l.0:iflt %6, %7 goto blklab13 : int
l.1:const %8 = false : bool
-------------------------------
Out:{_8}

In:{first, second, i, _6, _7}
blklab13 [ELSE] 
-------------------------------
l.0:ifge %6, %7 goto blklab13 : int
l.1:const %9 = 1 : int
l.2:add %10 = %3, %9 : int
l.3:assign %3 = %10  : int
-------------------------------
Out:{first, second, i}

In:{_8}
return_8 [RETURN] 
-------------------------------
l.0:return %8
-------------------------------
Out:{_8}

In:{first, second, i}
blklab12 [BLOCK] 
Out:{first, second, i}

In:{_11}
return_11 [RETURN] 
-------------------------------
l.0:return %11
-------------------------------
Out:{_11}

In:{}
exit [EXIT] 
Out:{}

###### Live variables for add function. ######
In:{first, second}
entry [ENTRY] 
Out:{first, second}

In:{first, second}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:assign %3 = %4  : int
-------------------------------
Out:{first, second, i}

In:{first, second, i}
blklab15 [LOOP_HEADER] 
Out:{first, second, i}

In:{first, second, i}
blklab15 [LOOP_BODY] 
-------------------------------
l.0:lengthof %5 = %0 : int[]
l.1:ifge %3, %5 goto blklab15 : int
l.2:indexof %6 = %0, %3 : int[]
l.3:indexof %7 = %1, %3 : int[]
l.4:add %8 = %6, %7 : int
-------------------------------
Out:{first, second, i}

In:{first}
blklab15 [LOOP_EXIT] 
Out:{first}

In:{first, second, i}
Update9 [UPDATE] 
-------------------------------
l.0:update %0[%3] = %8 : int[] -> int[]
-------------------------------
Out:{first, second, i}

In:{first, second, i}
Update9 [BLOCK] 
-------------------------------
l.0:const %9 = 1 : int
l.1:add %10 = %3, %9 : int
l.2:assign %3 = %10  : int
-------------------------------
Out:{first, second, i}

In:{first, second, i}
blklab16 [BLOCK] 
Out:{first, second, i}

In:{first}
return_0 [RETURN] 
-------------------------------
l.0:return %0
-------------------------------
Out:{first}

In:{}
exit [EXIT] 
Out:{}

###### Live variables for subtract function. ######
In:{first, second}
entry [ENTRY] 
Out:{first, second}

In:{first, second}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:assign %3 = %4  : int
-------------------------------
Out:{first, second, i}

In:{first, second, i}
blklab19 [LOOP_HEADER] 
Out:{first, second, i}

In:{first, second, i}
blklab19 [LOOP_BODY] 
-------------------------------
l.0:lengthof %5 = %0 : int[]
l.1:ifge %3, %5 goto blklab19 : int
l.2:indexof %6 = %0, %3 : int[]
l.3:indexof %7 = %1, %3 : int[]
l.4:sub %8 = %6, %7 : int
-------------------------------
Out:{first, second, i}

In:{first}
blklab19 [LOOP_EXIT] 
Out:{first}

In:{first, second, i}
Update9 [UPDATE] 
-------------------------------
l.0:update %0[%3] = %8 : int[] -> int[]
-------------------------------
Out:{first, second, i}

In:{first, second, i}
Update9 [BLOCK] 
-------------------------------
l.0:const %9 = 1 : int
l.1:add %10 = %3, %9 : int
l.2:assign %3 = %10  : int
-------------------------------
Out:{first, second, i}

In:{first, second, i}
blklab20 [BLOCK] 
Out:{first, second, i}

In:{first}
return_0 [RETURN] 
-------------------------------
l.0:return %0
-------------------------------
Out:{first}

In:{}
exit [EXIT] 
Out:{}

###### Live variables for calculateChange function. ######
In:{till, change, _13}
entry [ENTRY] 
Out:{till, change, _13}

In:{till, change, _13}
code [BLOCK] 
-------------------------------
l.0:const %6 = 0 : int
-------------------------------
Out:{till, change, _6, _13}

In:{till, change, _13, _6}
blklab25 [CONDITION] 
Out:{till, change, _6, _13}

In:{change, _6}
blklab25 [IF] 
-------------------------------
l.0:ifeq %1, %6 goto blklab25 : int
l.1:invoke (%7) = () cashtill:Cash : function()->(cashtill:Cash)
-------------------------------
Out:{_7}

In:{till, change, _13, _6}
blklab25 [ELSE] 
-------------------------------
l.0:ifne %1, %6 goto blklab25 : int
l.1:const %8 = 0 : int
l.2:assign %3 = %8  : int
-------------------------------
Out:{till, change, i, _13}

In:{_7}
return_7 [RETURN] 
-------------------------------
l.0:return %7
-------------------------------
Out:{_7}

In:{}
blklab26 [BLOCK] 
Out:{}

In:{till, change, i, _13}
blklab27 [LOOP_HEADER] 
Out:{till, change, i, _13}

In:{till, change, i, _13}
blklab27 [LOOP_BODY] 
-------------------------------
l.0:lengthof %9 = %0 : int[]
l.1:ifge %3, %9 goto blklab27 : int
l.2:indexof %10 = %0, %3 : int[]
l.3:const %11 = 0 : int
-------------------------------
Out:{till, change, i, _10, _11, _13}

In:{}
blklab27 [LOOP_EXIT] 
-------------------------------
l.0:const %26 = null : null
-------------------------------
Out:{_26}

In:{till, change, i, _10, _11, _13}
blklab29 [CONDITION] 
Out:{till, change, i, _10, _11, _13}

In:{till, change, _10, i, _11}
blklab29 [IF] 
-------------------------------
l.0:ifgt %10, %11 goto blklab29 : int
l.1:const %12 = [1,5,10,20,50,100,500,1000] : int[]
l.2:indexof %13 = %12, %3 : int[]
l.3:ifle %13, %1 goto blklab29 : int
l.4:assign %4 = %0  : int[]
l.5:indexof %14 = %4, %3 : int[]
l.6:const %15 = 1 : int
l.7:sub %16 = %14, %15 : int
-------------------------------
Out:{till, change, i, tmp, _10, _11, _13}

In:{till, change, _10, i, _11, _13}
blklab29 [ELSE] 
-------------------------------
l.0:ifle %10, %11 goto blklab29 : int
l.1:ifgt %13, %1 goto blklab29 : int
l.2:const %24 = 1 : int
l.3:add %25 = %3, %24 : int
l.4:assign %3 = %25  : int
-------------------------------
Out:{till, change, i, _13}

In:{change, i, tmp}
Update22 [UPDATE] 
-------------------------------
l.0:update %4[%3] = %16 : int[] -> int[]
-------------------------------
Out:{change, i, tmp}

In:{change, i, tmp}
Update22 [BLOCK] 
-------------------------------
l.0:const %18 = [1,5,10,20,50,100,500,1000] : int[]
l.1:indexof %19 = %18, %3 : int[]
l.2:sub %20 = %1, %19 : int
-------------------------------
Out:{i, tmp, _20}

In:{tmp, _20, i}
calculateChange26 [INVOKE] 
-------------------------------
l.0:invoke (%17) = (%4, %20) cashtill:calculateChange : function(cashtill:Cash,cashtill:nat)->(cashtill:Cash|null)
-------------------------------
Out:{_17, i}

In:{_17, i}
calculateChange26 [BLOCK] 
-------------------------------
l.0:assign %5 = %17  : null|int[]
l.1:ifis %5, null goto blklab30 : null|int[]
l.2:indexof %21 = %5, %3 : int[]
l.3:const %22 = 1 : int
l.4:add %23 = %21, %22 : int
-------------------------------
Out:{chg}

In:{chg}
Update32 [UPDATE] 
-------------------------------
l.0:update %5[%3] = %23 : int[] -> int[]
-------------------------------
Out:{chg}

In:{chg}
Update32 [BLOCK] 
Out:{chg}

In:{chg}
return_5 [RETURN] 
-------------------------------
l.0:return %5
-------------------------------
Out:{chg}

In:{till, change, i, _10, _11, _13}
blklab30 [BLOCK] 
Out:{till, change, i, _10, _11, _13}

In:{till, change, i, _13}
blklab28 [BLOCK] 
Out:{till, change, i, _13}

In:{_26}
return_26 [RETURN] 
-------------------------------
l.0:return %26
-------------------------------
Out:{_26}

In:{}
exit [EXIT] 
Out:{}

###### Live variables for toString function. ######
In:{c}
entry [ENTRY] 
Out:{c}

In:{c}
code [BLOCK] 
-------------------------------
l.0:const %6 = [] : void[]
l.1:assign %2 = %6  : void[]
l.2:const %7 = true : bool
l.3:assign %3 = %7  : bool
l.4:const %8 = 0 : int
l.5:assign %4 = %8  : int
-------------------------------
Out:{c, r, firstTime, i}

In:{c, r, firstTime, i}
blklab31 [LOOP_HEADER] 
Out:{c, r, firstTime, i}

In:{c, r, firstTime, i}
blklab31 [LOOP_BODY] 
-------------------------------
l.0:lengthof %9 = %0 : int[]
l.1:ifge %4, %9 goto blklab31 : int
l.2:indexof %10 = %0, %4 : int[]
l.3:assign %5 = %10  : int
l.4:const %11 = 0 : int
-------------------------------
Out:{c, r, firstTime, i, amt, _11}

In:{r}
blklab31 [LOOP_EXIT] 
-------------------------------
l.0:const %25 = [] : void[]
-------------------------------
Out:{r, _25}

In:{c, r, firstTime, i, amt, _11}
blklab33 [CONDITION] 
Out:{c, r, firstTime, i, amt, _11}

In:{c, r, firstTime, i, amt, _11}
blklab33 [IF] 
-------------------------------
l.0:ifne %5, %11 goto blklab33 : int
l.1:const %12 = true : bool
-------------------------------
Out:{c, r, firstTime, i, amt, _11, _12}

In:{c, r, firstTime, _11, i, amt}
blklab33 [ELSE] 
-------------------------------
l.0:ifeq %5, %11 goto blklab33 : int
l.1:const %23 = 1 : int
l.2:add %24 = %4, %23 : int
l.3:assign %4 = %24  : int
-------------------------------
Out:{c, r, firstTime, i}

In:{c, r, firstTime, i, amt, _11, _12}
blklab34 [CONDITION] 
Out:{c, r, firstTime, i, amt, _11, _12}

In:{c, r, firstTime, i, amt, _11, _12}
blklab34 [IF] 
-------------------------------
l.0:ifne %3, %12 goto blklab34 : bool
l.1:const %14 = [44,32] : int[]
-------------------------------
Out:{c, r, firstTime, i, amt, _11, _12, _14}

In:{c, r, firstTime, i, amt, _11, _12}
blklab34 [ELSE] 
-------------------------------
l.0:ifeq %3, %12 goto blklab34 : bool
l.1:const %15 = false : bool
l.2:assign %3 = %15  : bool
l.3:invoke (%17) = (%5) whiley/lang/Int:toString : function(int)->(whiley/lang/ASCII:string)
-------------------------------
Out:{c, _17, r, firstTime, i, amt, _11}

In:{c, r, firstTime, i, amt, _11, _12, _14}
append17 [INVOKE] 
-------------------------------
l.0:invoke (%13) = (%2, %14) whiley/lang/Array:append : function(int[],int[])->(int[])
-------------------------------
Out:{c, firstTime, i, amt, _11, _12, _13}

In:{c, firstTime, i, amt, _11, _12, _13}
append17 [BLOCK] 
-------------------------------
l.0:assign %2 = %13  : int[]
-------------------------------
Out:{c, r, firstTime, i, amt, _11, _12}

In:{c, _17, r, firstTime, i, amt, _11}
append23 [INVOKE] 
-------------------------------
l.0:invoke (%16) = (%2, %17) whiley/lang/Array:append : function(int[],int[])->(int[])
-------------------------------
Out:{_16, c, firstTime, i, amt, _11}

In:{c, _16, firstTime, i, amt, _11}
append23 [BLOCK] 
-------------------------------
l.0:assign %2 = %16  : int[]
l.1:const %19 = [32,120,32] : int[]
-------------------------------
Out:{c, r, _19, firstTime, i, amt, _11}

In:{c, r, firstTime, _19, i, amt, _11}
append26 [INVOKE] 
-------------------------------
l.0:invoke (%18) = (%2, %19) whiley/lang/Array:append : function(int[],int[])->(int[])
-------------------------------
Out:{c, _18, firstTime, i, amt, _11}

In:{c, _18, firstTime, i, amt, _11}
append26 [BLOCK] 
-------------------------------
l.0:assign %2 = %18  : int[]
l.1:const %21 = [[49,99],[53,99],[49,48,99],[50,48,99],[53,48,99],[36,49],[36,53],[36,49,48]] : int[][]
l.2:indexof %22 = %21, %4 : int[][]
-------------------------------
Out:{c, r, firstTime, i, amt, _22, _11}

In:{c, r, firstTime, i, amt, _22, _11}
append30 [INVOKE] 
-------------------------------
l.0:invoke (%20) = (%2, %22) whiley/lang/Array:append : function(int[],int[])->(int[])
-------------------------------
Out:{c, firstTime, _20, i, amt, _11}

In:{c, firstTime, i, _20, amt, _11}
append30 [BLOCK] 
-------------------------------
l.0:assign %2 = %20  : int[]
-------------------------------
Out:{c, r, firstTime, i, amt, _11}

In:{c, r, firstTime, i}
blklab32 [BLOCK] 
Out:{c, r, firstTime, i}

In:{_25, r}
blklab35 [CONDITION] 
Out:{r, _25}

In:{_25, r}
blklab35 [IF] 
-------------------------------
l.0:ifeq %2, %25 goto blklab35 : int[]
l.1:const %26 = [40,110,111,116,104,105,110,103,41] : int[]
l.2:assign %2 = %26  : int[]
-------------------------------
Out:{r, _25}

In:{_25, r}
blklab35 [ELSE] 
-------------------------------
l.0:ifne %2, %25 goto blklab35 : int[]
-------------------------------
Out:{r}

In:{r}
return_2 [RETURN] 
-------------------------------
l.0:return %2
-------------------------------
Out:{r}

In:{}
exit [EXIT] 
Out:{}

###### Live variables for buy function. ######
In:{console, till, given, cost}
entry [ENTRY] 
Out:{console, till, given, cost}

In:{console, till, given, cost}
code [BLOCK] 
-------------------------------
l.0:fieldload %6 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.1:fieldload %7 = %6 println_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.2:const %8 = [45,45] : int[]
l.3:indirectinvoke () = %7 (%8) : method(int[])->()
l.4:fieldload %9 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.5:fieldload %10 = %9 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.6:const %11 = [67,117,115,116,111,109,101,114,32,119,97,110,116,115,32,116,111,32,112,117,114,99,104,97,115,101,32,105,116,101,109,32,102,111,114,32] : int[]
l.7:indirectinvoke () = %10 (%11) : method(int[])->()
l.8:fieldload %12 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.9:fieldload %13 = %12 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.10:invoke (%14) = (%3) whiley/lang/Int:toString : function(int)->(whiley/lang/ASCII:string)
l.11:indirectinvoke () = %13 (%14) : method(int[])->()
l.12:fieldload %15 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.13:fieldload %16 = %15 println_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.14:const %17 = [99,46] : int[]
l.15:indirectinvoke () = %16 (%17) : method(int[])->()
l.16:fieldload %18 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.17:fieldload %19 = %18 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.18:const %20 = [67,117,115,116,111,109,101,114,32,103,105,118,101,115,58,32] : int[]
l.19:indirectinvoke () = %19 (%20) : method(int[])->()
l.20:fieldload %21 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.21:fieldload %22 = %21 println_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
-------------------------------
Out:{console, till, given, cost, _22}

In:{console, till, given, cost, _22}
toString23 [INVOKE] 
-------------------------------
l.0:invoke (%23) = (%2) cashtill:toString : function(cashtill:Cash)->(whiley/lang/ASCII:string)
-------------------------------
Out:{console, till, given, cost, _22, _23}

In:{console, till, given, cost, _22, _23}
toString23 [BLOCK] 
-------------------------------
l.0:indirectinvoke () = %22 (%23) : method(int[])->()
-------------------------------
Out:{console, till, given, cost}

In:{console, till, given, cost}
total25 [INVOKE] 
-------------------------------
l.0:invoke (%24) = (%2) cashtill:total : function(cashtill:Cash)->(int)
-------------------------------
Out:{console, till, given, cost, _24}

In:{console, _24, till, given, cost}
total25 [BLOCK] 
Out:{console, till, given, cost, _24}

In:{console, _24, till, given, cost}
blklab36 [CONDITION] 
Out:{console, till, given, cost, _24}

In:{console, _24, till, cost}
blklab36 [IF] 
-------------------------------
l.0:iflt %24, %3 goto blklab36 : int
l.1:fieldload %25 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %26 = %25 println_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:const %27 = [67,117,115,116,111,109,101,114,32,104,97,115,32,110,111,116,32,103,105,118,101,110,32,101,110,111,117,103,104,32,99,97,115,104,33] : int[]
l.4:indirectinvoke () = %26 (%27) : method(int[])->()
-------------------------------
Out:{till}

In:{console, _24, till, given, cost}
blklab36 [ELSE] 
-------------------------------
l.0:ifge %24, %3 goto blklab36 : int
-------------------------------
Out:{console, till, given, cost}

In:{till}
blklab37 [BLOCK] 
Out:{till}

In:{console, till, given, cost}
total33 [INVOKE] 
-------------------------------
l.0:invoke (%29) = (%2) cashtill:total : function(cashtill:Cash)->(int)
-------------------------------
Out:{console, till, given, cost, _29}

In:{console, till, given, cost, _29}
total33 [BLOCK] 
-------------------------------
l.0:sub %30 = %29, %3 : int
-------------------------------
Out:{console, till, given, _30}

In:{console, till, given, _30}
calculateChange35 [INVOKE] 
-------------------------------
l.0:invoke (%28) = (%1, %30) cashtill:calculateChange : function(cashtill:Cash,cashtill:nat)->(cashtill:Cash|null)
-------------------------------
Out:{console, till, given, _28}

In:{console, till, given, _28}
calculateChange35 [BLOCK] 
-------------------------------
l.0:assign %5 = %28  : null|int[]
l.1:ifis %5, null goto blklab40 : null|int[]
-------------------------------
Out:{console, till, given, change}

In:{console, till, given, change}
blklab38 [BLOCK] 
-------------------------------
l.0:fieldload %34 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.1:fieldload %35 = %34 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.2:const %36 = [67,104,97,110,103,101,32,103,105,118,101,110,58,32] : int[]
l.3:indirectinvoke () = %35 (%36) : method(int[])->()
l.4:fieldload %37 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.5:fieldload %38 = %37 println_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
-------------------------------
Out:{console, till, given, change, _38}

In:{console, till}
blklab40 [BLOCK] 
-------------------------------
l.0:fieldload %31 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.1:fieldload %32 = %31 println_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.2:const %33 = [67,97,115,104,32,116,105,108,108,32,99,97,110,110,111,116,32,103,105,118,101,32,101,120,97,99,116,32,99,104,97,110,103,101,33] : int[]
l.3:indirectinvoke () = %32 (%33) : method(int[])->()
-------------------------------
Out:{till}

In:{till}
blklab39 [BLOCK] 
Out:{till}

In:{console, till, given, change, _38}
toString52 [INVOKE] 
-------------------------------
l.0:invoke (%39) = (%5) cashtill:toString : function(cashtill:Cash)->(whiley/lang/ASCII:string)
-------------------------------
Out:{console, till, given, change, _38, _39}

In:{console, till, given, change, _38, _39}
toString52 [BLOCK] 
-------------------------------
l.0:indirectinvoke () = %38 (%39) : method(int[])->()
-------------------------------
Out:{console, till, given, change}

In:{console, till, given, change}
add54 [INVOKE] 
-------------------------------
l.0:invoke (%40) = (%1, %2) cashtill:add : function(cashtill:Cash,cashtill:Cash)->(cashtill:Cash)
-------------------------------
Out:{console, change, _40}

In:{console, _40, change}
add54 [BLOCK] 
-------------------------------
l.0:assign %1 = %40  : int[]
-------------------------------
Out:{console, till, change}

In:{console, till, change}
subtract56 [INVOKE] 
-------------------------------
l.0:invoke (%41) = (%1, %5) cashtill:subtract : function(cashtill:Cash,cashtill:Cash)->(cashtill:Cash)
-------------------------------
Out:{console, _41}

In:{console, _41}
subtract56 [BLOCK] 
-------------------------------
l.0:assign %1 = %41  : int[]
l.1:fieldload %42 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %43 = %42 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:const %44 = [84,105,108,108,58,32] : int[]
l.4:indirectinvoke () = %43 (%44) : method(int[])->()
l.5:fieldload %45 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.6:fieldload %46 = %45 println_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
-------------------------------
Out:{till, _46}

In:{till, _46}
toString64 [INVOKE] 
-------------------------------
l.0:invoke (%47) = (%1) cashtill:toString : function(cashtill:Cash)->(whiley/lang/ASCII:string)
-------------------------------
Out:{till, _46, _47}

In:{till, _46, _47}
toString64 [BLOCK] 
-------------------------------
l.0:indirectinvoke () = %46 (%47) : method(int[])->()
-------------------------------
Out:{till}

In:{till}
return_1 [RETURN] 
-------------------------------
l.0:return %1
-------------------------------
Out:{till}

In:{}
exit [EXIT] 
Out:{}

###### Live variables for main function. ######
In:{console}
entry [ENTRY] 
Out:{console}

In:{console}
code [BLOCK] 
-------------------------------
l.0:const %2 = 5 : int
l.1:const %3 = 3 : int
l.2:const %4 = 3 : int
l.3:const %5 = 1 : int
l.4:const %6 = 1 : int
l.5:const %7 = 3 : int
l.6:const %8 = 0 : int
l.7:const %9 = 0 : int
l.8:newlist %10 = (%2, %3, %4, %5, %6, %7, %8, %9) : int[]
l.9:assign %1 = %10  : int[]
l.10:fieldload %11 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.11:fieldload %12 = %11 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.12:const %13 = [84,105,108,108,58,32] : int[]
l.13:indirectinvoke () = %12 (%13) : method(int[])->()
l.14:fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.15:fieldload %15 = %14 println_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
-------------------------------
Out:{console, till, _15}

In:{console, till, _15}
toString17 [INVOKE] 
-------------------------------
l.0:invoke (%16) = (%1) cashtill:toString : function(cashtill:Cash)->(whiley/lang/ASCII:string)
-------------------------------
Out:{console, _16, till, _15}

In:{console, _16, till, _15}
toString17 [BLOCK] 
-------------------------------
l.0:indirectinvoke () = %15 (%16) : method(int[])->()
l.1:const %19 = 5 : int
l.2:newlist %20 = (%19) : int[]
-------------------------------
Out:{console, till, _20}

In:{console, till, _20}
Cash21 [INVOKE] 
-------------------------------
l.0:invoke (%18) = (%20) cashtill:Cash : function(cashtill:nat[])->(cashtill:Cash)
-------------------------------
Out:{console, till, _18}

In:{console, till, _18}
Cash21 [BLOCK] 
-------------------------------
l.0:const %21 = 85 : int
-------------------------------
Out:{console, till, _18, _21}

In:{console, till, _18, _21}
buy23 [INVOKE] 
-------------------------------
l.0:invoke (%17) = (%0, %1, %18, %21) cashtill:buy : method(whiley/lang/System:Console,cashtill:Cash,cashtill:Cash,int)->(cashtill:Cash)
-------------------------------
Out:{console, _17}

In:{console, _17}
buy23 [BLOCK] 
-------------------------------
l.0:assign %1 = %17  : int[]
l.1:const %24 = 5 : int
l.2:newlist %25 = (%24) : int[]
-------------------------------
Out:{console, till, _25}

In:{console, till, _25}
Cash27 [INVOKE] 
-------------------------------
l.0:invoke (%23) = (%25) cashtill:Cash : function(cashtill:nat[])->(cashtill:Cash)
-------------------------------
Out:{console, till, _23}

In:{console, till, _23}
Cash27 [BLOCK] 
-------------------------------
l.0:const %26 = 105 : int
-------------------------------
Out:{console, till, _23, _26}

In:{console, till, _26, _23}
buy29 [INVOKE] 
-------------------------------
l.0:invoke (%22) = (%0, %1, %23, %26) cashtill:buy : method(whiley/lang/System:Console,cashtill:Cash,cashtill:Cash,int)->(cashtill:Cash)
-------------------------------
Out:{console, _22}

In:{console, _22}
buy29 [BLOCK] 
-------------------------------
l.0:assign %1 = %22  : int[]
l.1:const %29 = 7 : int
l.2:newlist %30 = (%29) : int[]
-------------------------------
Out:{console, till, _30}

In:{console, till, _30}
Cash33 [INVOKE] 
-------------------------------
l.0:invoke (%28) = (%30) cashtill:Cash : function(cashtill:nat[])->(cashtill:Cash)
-------------------------------
Out:{console, till, _28}

In:{console, till, _28}
Cash33 [BLOCK] 
-------------------------------
l.0:const %31 = 5 : int
-------------------------------
Out:{console, till, _28, _31}

In:{console, till, _28, _31}
buy35 [INVOKE] 
-------------------------------
l.0:invoke (%27) = (%0, %1, %28, %31) cashtill:buy : method(whiley/lang/System:Console,cashtill:Cash,cashtill:Cash,int)->(cashtill:Cash)
-------------------------------
Out:{console, _27}

In:{console, _27}
buy35 [BLOCK] 
-------------------------------
l.0:assign %1 = %27  : int[]
l.1:const %34 = 6 : int
l.2:newlist %35 = (%34) : int[]
-------------------------------
Out:{console, till, _35}

In:{console, till, _35}
Cash39 [INVOKE] 
-------------------------------
l.0:invoke (%33) = (%35) cashtill:Cash : function(cashtill:nat[])->(cashtill:Cash)
-------------------------------
Out:{console, till, _33}

In:{console, till, _33}
Cash39 [BLOCK] 
-------------------------------
l.0:const %36 = 305 : int
-------------------------------
Out:{console, till, _33, _36}

In:{console, till, _33, _36}
buy41 [INVOKE] 
-------------------------------
l.0:invoke (%32) = (%0, %1, %33, %36) cashtill:buy : method(whiley/lang/System:Console,cashtill:Cash,cashtill:Cash,int)->(cashtill:Cash)
-------------------------------
Out:{_32}

In:{_32}
buy41 [BLOCK] 
-------------------------------
l.0:assign %1 = %32  : int[]
-------------------------------
Out:{}

In:{}
exit [EXIT] 
Out:{}


Copy elimination analysis completed. File: cashtill.wyil
