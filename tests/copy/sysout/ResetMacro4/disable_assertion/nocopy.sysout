add.0 [	lengthof %8 = %0 : int[]]
add.1 [	assign %3 = %8  : int]
add.2 [	const %9 = 0 : int]
add.3 [	arraygen %10 = [9; 3] : int[]]
add.4 [	assign %4 = %10  : int[]]
add.5 [	const %11 = 0 : int]
add.6 [	assign %5 = %11  : int]
add.7 [	loop (%0, %1, %5, %6, %7, %12, %13, %14, %15, %16, %17)]
add.8 [	ifge %5, %3 goto blklab0 : int]
add.9 [	indexof %12 = %0, %5 : int[]]
add.10 [	assign %6 = %12  : int]
add.11 [	indexof %13 = %1, %5 : int[]]
add.12 [	assign %7 = %13  : int]
add.13 [	add %14 = %6, %7 : int]
add.14 [	update %0[%5] = %14 : int[] -> int[]]
add.15 [	const %15 = 0 : int]
add.16 [	update %1[%5] = %15 : int[] -> int[]]
add.17 [	const %16 = 1 : int]
add.18 [	add %17 = %5, %16 : int]
add.19 [	assign %5 = %17  : int]
add.20 [.blklab1]
add.21 [.blklab0]
add.22 [	return %0]
add.23 [	return]
main.0 [	const %4 = 0 : int]
main.1 [	const %5 = 10 : int]
main.2 [	arraygen %6 = [4; 5] : int[]]
main.3 [	assign %1 = %6  : int[]]
main.4 [	const %7 = 0 : int]
main.5 [	assign %2 = %7  : int]
main.6 [	loop (%1, %2, %8, %9, %10)]
main.7 [	const %8 = 10 : int]
main.8 [	ifge %2, %8 goto blklab2 : int]
main.9 [	update %1[%2] = %2 : int[] -> int[]]
main.10 [	const %9 = 1 : int]
main.11 [	add %10 = %2, %9 : int]
main.12 [	assign %2 = %10  : int]
main.13 [.blklab3]
main.14 [.blklab2]
main.15 [	invoke (%11) = (%1, %1) ResetMacro4:add : function(int[],int[])->(int[])]
main.16 [	assign %3 = %11  : int[]]
main.17 [	const %12 = 0 : int]
main.18 [	assign %2 = %12  : int]
main.19 [	loop (%2, %13, %14, %15, %16, %17, %18, %19, %20, %21)]
main.20 [	const %13 = 10 : int]
main.21 [	ifge %2, %13 goto blklab4 : int]
main.22 [	fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.23 [	fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.24 [	indexof %16 = %3, %2 : int[]]
main.25 [	indirectinvoke () = %15 (%16) : method(any)->()]
main.26 [	assert]
main.27 [	const %20 = 1 : int]
main.28 [	add %21 = %2, %20 : int]
main.29 [	assign %2 = %21  : int]
main.30 [.blklab5]
main.31 [.blklab4]
main.32 [	return]
root->add
root->main
add.0 [	lengthof %8 = %0 : int[]]
add.1 [	assign %3 = %8  : int]
add.2 [	const %9 = 0 : int]
add.3 [	arraygen %10 = [9; 3] : int[]]
add.4 [	assign %4 = %10  : int[]]
add.5 [	const %11 = 0 : int]
add.6 [	assign %5 = %11  : int]
add.7 [	loop (%0, %1, %5, %6, %7, %12, %13, %14, %15, %16, %17)]
add.8 [	ifge %5, %3 goto blklab0 : int]
add.9 [	indexof %12 = %0, %5 : int[]]
add.10 [	assign %6 = %12  : int]
add.11 [	indexof %13 = %1, %5 : int[]]
add.12 [	assign %7 = %13  : int]
add.13 [	add %14 = %6, %7 : int]
add.14 [	update %0[%5] = %14 : int[] -> int[]]
add.15 [	const %15 = 0 : int]
add.16 [	update %1[%5] = %15 : int[] -> int[]]
add.17 [	const %16 = 1 : int]
add.18 [	add %17 = %5, %16 : int]
add.19 [	assign %5 = %17  : int]
add.20 [.blklab1]
add.21 [.blklab0]
add.22 [	return %0]
add.23 [	return]
main.0 [	const %4 = 0 : int]
main.1 [	const %5 = 10 : int]
main.2 [	arraygen %6 = [4; 5] : int[]]
main.3 [	assign %1 = %6  : int[]]
main.4 [	const %7 = 0 : int]
main.5 [	assign %2 = %7  : int]
main.6 [	loop (%1, %2, %8, %9, %10)]
main.7 [	const %8 = 10 : int]
main.8 [	ifge %2, %8 goto blklab2 : int]
main.9 [	update %1[%2] = %2 : int[] -> int[]]
main.10 [	const %9 = 1 : int]
main.11 [	add %10 = %2, %9 : int]
main.12 [	assign %2 = %10  : int]
main.13 [.blklab3]
main.14 [.blklab2]
main.15 [	invoke (%11) = (%1, %1) ResetMacro4:add : function(int[],int[])->(int[])]
main.16 [	assign %3 = %11  : int[]]
main.17 [	const %12 = 0 : int]
main.18 [	assign %2 = %12  : int]
main.19 [	loop (%2, %13, %14, %15, %16, %17, %18, %19, %20, %21)]
main.20 [	const %13 = 10 : int]
main.21 [	ifge %2, %13 goto blklab4 : int]
main.22 [	fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.23 [	fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.24 [	indexof %16 = %3, %2 : int[]]
main.25 [	indirectinvoke () = %15 (%16) : method(any)->()]
main.26 [	assert]
main.27 [	const %20 = 1 : int]
main.28 [	add %21 = %2, %20 : int]
main.29 [	assign %2 = %21  : int]
main.30 [.blklab5]
main.31 [.blklab4]
main.32 [	return]
add.0 [	lengthof %8 = %0 : int[]]
add.1 [	assign %3 = %8  : int]
add.2 [	const %9 = 0 : int]
add.3 [	arraygen %10 = [9; 3] : int[]]
add.4 [	assign %4 = %10  : int[]]
add.5 [	const %11 = 0 : int]
add.6 [	assign %5 = %11  : int]
add.7 [	loop (%0, %1, %5, %6, %7, %12, %13, %14, %15, %16, %17)]
add.8 [	ifge %5, %3 goto blklab0 : int]
add.9 [	indexof %12 = %0, %5 : int[]]
add.10 [	assign %6 = %12  : int]
add.11 [	indexof %13 = %1, %5 : int[]]
add.12 [	assign %7 = %13  : int]
add.13 [	add %14 = %6, %7 : int]
add.14 [	update %0[%5] = %14 : int[] -> int[]]
add.15 [	const %15 = 0 : int]
add.16 [	update %1[%5] = %15 : int[] -> int[]]
add.17 [	const %16 = 1 : int]
add.18 [	add %17 = %5, %16 : int]
add.19 [	assign %5 = %17  : int]
add.20 [.blklab1]
add.21 [.blklab0]
add.22 [	return %0]
add.23 [	return]
main.0 [	const %4 = 0 : int]
main.1 [	const %5 = 10 : int]
main.2 [	arraygen %6 = [4; 5] : int[]]
main.3 [	assign %1 = %6  : int[]]
main.4 [	const %7 = 0 : int]
main.5 [	assign %2 = %7  : int]
main.6 [	loop (%1, %2, %8, %9, %10)]
main.7 [	const %8 = 10 : int]
main.8 [	ifge %2, %8 goto blklab2 : int]
main.9 [	update %1[%2] = %2 : int[] -> int[]]
main.10 [	const %9 = 1 : int]
main.11 [	add %10 = %2, %9 : int]
main.12 [	assign %2 = %10  : int]
main.13 [.blklab3]
main.14 [.blklab2]
main.15 [	invoke (%11) = (%1, %1) ResetMacro4:add : function(int[],int[])->(int[])]
main.16 [	assign %3 = %11  : int[]]
main.17 [	const %12 = 0 : int]
main.18 [	assign %2 = %12  : int]
main.19 [	loop (%2, %13, %14, %15, %16, %17, %18, %19, %20, %21)]
main.20 [	const %13 = 10 : int]
main.21 [	ifge %2, %13 goto blklab4 : int]
main.22 [	fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.23 [	fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.24 [	indexof %16 = %3, %2 : int[]]
main.25 [	indirectinvoke () = %15 (%16) : method(any)->()]
main.26 [	assert]
main.27 [	const %20 = 1 : int]
main.28 [	add %21 = %2, %20 : int]
main.29 [	assign %2 = %21  : int]
main.30 [.blklab5]
main.31 [.blklab4]
main.32 [	return]
###### Live analysis for add function. ######
Iteration 1
In:{[]}
blklab1 [BLOCK] 
Out:{[]}

In:{[0]}
blklab0 [LOOP_EXIT] 
Out:{[0]}

In:{[0, 1, 3, 5]}
blklab0 [LOOP_BODY] 
-------------------------------
l.0:ifge %5, %3 goto blklab0 : int
l.1:indexof %12 = %0, %5 : int[]
l.2:assign %6 = %12  : int
l.3:indexof %13 = %1, %5 : int[]
l.4:assign %7 = %13  : int
l.5:add %14 = %6, %7 : int
l.6:update %0[%5] = %14 : int[] -> int[]
l.7:const %15 = 0 : int
l.8:update %1[%5] = %15 : int[] -> int[]
l.9:const %16 = 1 : int
l.10:add %17 = %5, %16 : int
l.11:assign %5 = %17  : int
-------------------------------
Out:{[]}

In:{[0, 1, 3, 5]}
blklab0 [LOOP_HEADER] 
Out:{[0, 1, 3, 5]}

In:{[0, 1]}
code [BLOCK] 
-------------------------------
l.0:lengthof %8 = %0 : int[]
l.1:assign %3 = %8  : int
l.2:const %9 = 0 : int
l.3:arraygen %10 = [9; 3] : int[]
l.4:assign %4 = %10  : int[]
l.5:const %11 = 0 : int
l.6:assign %5 = %11  : int
-------------------------------
Out:{[0, 1, 3, 5]}

In:{[0, 1]}
entry [ENTRY] 
Out:{[0, 1]}

###### Live analysis for add function. ######
Iteration 2
In:{[0, 1, 3, 5]}
blklab1 [BLOCK] 
Out:{[0, 1, 3, 5]}

In:{[0]}
blklab0 [LOOP_EXIT] 
Out:{[0]}

In:{[0, 1, 3, 5]}
blklab0 [LOOP_BODY] 
-------------------------------
l.0:ifge %5, %3 goto blklab0 : int
l.1:indexof %12 = %0, %5 : int[]
l.2:assign %6 = %12  : int
l.3:indexof %13 = %1, %5 : int[]
l.4:assign %7 = %13  : int
l.5:add %14 = %6, %7 : int
l.6:update %0[%5] = %14 : int[] -> int[]
l.7:const %15 = 0 : int
l.8:update %1[%5] = %15 : int[] -> int[]
l.9:const %16 = 1 : int
l.10:add %17 = %5, %16 : int
l.11:assign %5 = %17  : int
-------------------------------
Out:{[0, 1, 3, 5]}

In:{[0, 1, 3, 5]}
blklab0 [LOOP_HEADER] 
Out:{[0, 1, 3, 5]}

In:{[0, 1]}
code [BLOCK] 
-------------------------------
l.0:lengthof %8 = %0 : int[]
l.1:assign %3 = %8  : int
l.2:const %9 = 0 : int
l.3:arraygen %10 = [9; 3] : int[]
l.4:assign %4 = %10  : int[]
l.5:const %11 = 0 : int
l.6:assign %5 = %11  : int
-------------------------------
Out:{[0, 1, 3, 5]}

In:{[0, 1]}
entry [ENTRY] 
Out:{[0, 1]}

###### Live analysis for add function. ######
Iteration 3
In:{[0, 1, 3, 5]}
blklab1 [BLOCK] 
Out:{[0, 1, 3, 5]}

In:{[0]}
blklab0 [LOOP_EXIT] 
Out:{[0]}

In:{[0, 1, 3, 5]}
blklab0 [LOOP_BODY] 
-------------------------------
l.0:ifge %5, %3 goto blklab0 : int
l.1:indexof %12 = %0, %5 : int[]
l.2:assign %6 = %12  : int
l.3:indexof %13 = %1, %5 : int[]
l.4:assign %7 = %13  : int
l.5:add %14 = %6, %7 : int
l.6:update %0[%5] = %14 : int[] -> int[]
l.7:const %15 = 0 : int
l.8:update %1[%5] = %15 : int[] -> int[]
l.9:const %16 = 1 : int
l.10:add %17 = %5, %16 : int
l.11:assign %5 = %17  : int
-------------------------------
Out:{[0, 1, 3, 5]}

In:{[0, 1, 3, 5]}
blklab0 [LOOP_HEADER] 
Out:{[0, 1, 3, 5]}

In:{[0, 1]}
code [BLOCK] 
-------------------------------
l.0:lengthof %8 = %0 : int[]
l.1:assign %3 = %8  : int
l.2:const %9 = 0 : int
l.3:arraygen %10 = [9; 3] : int[]
l.4:assign %4 = %10  : int[]
l.5:const %11 = 0 : int
l.6:assign %5 = %11  : int
-------------------------------
Out:{[0, 1, 3, 5]}

In:{[0, 1]}
entry [ENTRY] 
Out:{[0, 1]}

###### Live variables for add function. ######
In:{a, b}
entry [ENTRY] 
Out:{a, b}

In:{a, b}
code [BLOCK] 
-------------------------------
l.0:lengthof %8 = %0 : int[]
l.1:assign %3 = %8  : int
l.2:const %9 = 0 : int
l.3:arraygen %10 = [9; 3] : int[]
l.4:assign %4 = %10  : int[]
l.5:const %11 = 0 : int
l.6:assign %5 = %11  : int
-------------------------------
Out:{a, b, length, i}

In:{a, b, length, i}
blklab0 [LOOP_HEADER] 
Out:{a, b, length, i}

In:{a, b, length, i}
blklab0 [LOOP_BODY] 
-------------------------------
l.0:ifge %5, %3 goto blklab0 : int
l.1:indexof %12 = %0, %5 : int[]
l.2:assign %6 = %12  : int
l.3:indexof %13 = %1, %5 : int[]
l.4:assign %7 = %13  : int
l.5:add %14 = %6, %7 : int
l.6:update %0[%5] = %14 : int[] -> int[]
l.7:const %15 = 0 : int
l.8:update %1[%5] = %15 : int[] -> int[]
l.9:const %16 = 1 : int
l.10:add %17 = %5, %16 : int
l.11:assign %5 = %17  : int
-------------------------------
Out:{a, b, length, i}

In:{a}
blklab0 [LOOP_EXIT] 
Out:{a}

In:{a, b, length, i}
blklab1 [BLOCK] 
Out:{a, b, length, i}

In:{a}
return_0 [RETURN] 
-------------------------------
l.0:return %0
-------------------------------
Out:{a}

In:{}
exit [EXIT] 
Out:{}

###### Live analysis for main function. ######
Iteration 1
In:{[]}
blklab5 [BLOCK] 
Out:{[]}

In:{[]}
blklab4 [LOOP_EXIT] 
Out:{[]}

In:{[0, 2, 3]}
blklab4 [LOOP_BODY] 
-------------------------------
l.0:const %13 = 10 : int
l.1:ifge %2, %13 goto blklab4 : int
l.2:fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.3:fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.4:indexof %16 = %3, %2 : int[]
l.5:indirectinvoke () = %15 (%16) : method(any)->()
l.6:const %20 = 1 : int
l.7:add %21 = %2, %20 : int
l.8:assign %2 = %21  : int
-------------------------------
Out:{[]}

In:{[0, 2, 3]}
blklab4 [LOOP_HEADER] 
Out:{[0, 2, 3]}

In:{[0, 11]}
add16 [BLOCK] 
-------------------------------
l.0:assign %3 = %11  : int[]
l.1:const %12 = 0 : int
l.2:assign %2 = %12  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0, 1]}
add16 [INVOKE] 
-------------------------------
l.0:invoke (%11) = (%1, %1) ResetMacro4:add : function(int[],int[])->(int[])
-------------------------------
Out:{[0, 11]}

In:{[]}
blklab3 [BLOCK] 
Out:{[]}

In:{[0, 1]}
blklab2 [LOOP_EXIT] 
Out:{[0, 1]}

In:{[1, 2]}
blklab2 [LOOP_BODY] 
-------------------------------
l.0:const %8 = 10 : int
l.1:ifge %2, %8 goto blklab2 : int
l.2:update %1[%2] = %2 : int[] -> int[]
l.3:const %9 = 1 : int
l.4:add %10 = %2, %9 : int
l.5:assign %2 = %10  : int
-------------------------------
Out:{[]}

In:{[0, 1, 2]}
blklab2 [LOOP_HEADER] 
Out:{[0, 1, 2]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 10 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %1 = %6  : int[]
l.4:const %7 = 0 : int
l.5:assign %2 = %7  : int
-------------------------------
Out:{[0, 1, 2]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live analysis for main function. ######
Iteration 2
In:{[0, 2, 3]}
blklab5 [BLOCK] 
Out:{[0, 2, 3]}

In:{[]}
blklab4 [LOOP_EXIT] 
Out:{[]}

In:{[0, 2, 3]}
blklab4 [LOOP_BODY] 
-------------------------------
l.0:const %13 = 10 : int
l.1:ifge %2, %13 goto blklab4 : int
l.2:fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.3:fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.4:indexof %16 = %3, %2 : int[]
l.5:indirectinvoke () = %15 (%16) : method(any)->()
l.6:const %20 = 1 : int
l.7:add %21 = %2, %20 : int
l.8:assign %2 = %21  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0, 2, 3]}
blklab4 [LOOP_HEADER] 
Out:{[0, 2, 3]}

In:{[0, 11]}
add16 [BLOCK] 
-------------------------------
l.0:assign %3 = %11  : int[]
l.1:const %12 = 0 : int
l.2:assign %2 = %12  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0, 1]}
add16 [INVOKE] 
-------------------------------
l.0:invoke (%11) = (%1, %1) ResetMacro4:add : function(int[],int[])->(int[])
-------------------------------
Out:{[0, 11]}

In:{[0, 1, 2]}
blklab3 [BLOCK] 
Out:{[0, 1, 2]}

In:{[0, 1]}
blklab2 [LOOP_EXIT] 
Out:{[0, 1]}

In:{[0, 1, 2]}
blklab2 [LOOP_BODY] 
-------------------------------
l.0:const %8 = 10 : int
l.1:ifge %2, %8 goto blklab2 : int
l.2:update %1[%2] = %2 : int[] -> int[]
l.3:const %9 = 1 : int
l.4:add %10 = %2, %9 : int
l.5:assign %2 = %10  : int
-------------------------------
Out:{[0, 1, 2]}

In:{[0, 1, 2]}
blklab2 [LOOP_HEADER] 
Out:{[0, 1, 2]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 10 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %1 = %6  : int[]
l.4:const %7 = 0 : int
l.5:assign %2 = %7  : int
-------------------------------
Out:{[0, 1, 2]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live analysis for main function. ######
Iteration 3
In:{[0, 2, 3]}
blklab5 [BLOCK] 
Out:{[0, 2, 3]}

In:{[]}
blklab4 [LOOP_EXIT] 
Out:{[]}

In:{[0, 2, 3]}
blklab4 [LOOP_BODY] 
-------------------------------
l.0:const %13 = 10 : int
l.1:ifge %2, %13 goto blklab4 : int
l.2:fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.3:fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.4:indexof %16 = %3, %2 : int[]
l.5:indirectinvoke () = %15 (%16) : method(any)->()
l.6:const %20 = 1 : int
l.7:add %21 = %2, %20 : int
l.8:assign %2 = %21  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0, 2, 3]}
blklab4 [LOOP_HEADER] 
Out:{[0, 2, 3]}

In:{[0, 11]}
add16 [BLOCK] 
-------------------------------
l.0:assign %3 = %11  : int[]
l.1:const %12 = 0 : int
l.2:assign %2 = %12  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0, 1]}
add16 [INVOKE] 
-------------------------------
l.0:invoke (%11) = (%1, %1) ResetMacro4:add : function(int[],int[])->(int[])
-------------------------------
Out:{[0, 11]}

In:{[0, 1, 2]}
blklab3 [BLOCK] 
Out:{[0, 1, 2]}

In:{[0, 1]}
blklab2 [LOOP_EXIT] 
Out:{[0, 1]}

In:{[0, 1, 2]}
blklab2 [LOOP_BODY] 
-------------------------------
l.0:const %8 = 10 : int
l.1:ifge %2, %8 goto blklab2 : int
l.2:update %1[%2] = %2 : int[] -> int[]
l.3:const %9 = 1 : int
l.4:add %10 = %2, %9 : int
l.5:assign %2 = %10  : int
-------------------------------
Out:{[0, 1, 2]}

In:{[0, 1, 2]}
blklab2 [LOOP_HEADER] 
Out:{[0, 1, 2]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 10 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %1 = %6  : int[]
l.4:const %7 = 0 : int
l.5:assign %2 = %7  : int
-------------------------------
Out:{[0, 1, 2]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live variables for main function. ######
In:{sys}
entry [ENTRY] 
Out:{sys}

In:{sys}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 10 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %1 = %6  : int[]
l.4:const %7 = 0 : int
l.5:assign %2 = %7  : int
-------------------------------
Out:{sys, a, i}

In:{sys, a, i}
blklab2 [LOOP_HEADER] 
Out:{sys, a, i}

In:{sys, a, i}
blklab2 [LOOP_BODY] 
-------------------------------
l.0:const %8 = 10 : int
l.1:ifge %2, %8 goto blklab2 : int
l.2:update %1[%2] = %2 : int[] -> int[]
l.3:const %9 = 1 : int
l.4:add %10 = %2, %9 : int
l.5:assign %2 = %10  : int
-------------------------------
Out:{sys, a, i}

In:{sys, a}
blklab2 [LOOP_EXIT] 
Out:{sys, a}

In:{sys, a, i}
blklab3 [BLOCK] 
Out:{sys, a, i}

In:{sys, a}
add16 [INVOKE] 
-------------------------------
l.0:invoke (%11) = (%1, %1) ResetMacro4:add : function(int[],int[])->(int[])
-------------------------------
Out:{sys, _11}

In:{sys, _11}
add16 [BLOCK] 
-------------------------------
l.0:assign %3 = %11  : int[]
l.1:const %12 = 0 : int
l.2:assign %2 = %12  : int
-------------------------------
Out:{sys, i, sum}

In:{sys, i, sum}
blklab4 [LOOP_HEADER] 
Out:{sys, i, sum}

In:{sys, i, sum}
blklab4 [LOOP_BODY] 
-------------------------------
l.0:const %13 = 10 : int
l.1:ifge %2, %13 goto blklab4 : int
l.2:fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.3:fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.4:indexof %16 = %3, %2 : int[]
l.5:indirectinvoke () = %15 (%16) : method(any)->()
l.6:const %20 = 1 : int
l.7:add %21 = %2, %20 : int
l.8:assign %2 = %21  : int
-------------------------------
Out:{sys, i, sum}

In:{}
blklab4 [LOOP_EXIT] 
Out:{}

In:{sys, i, sum}
blklab5 [BLOCK] 
Out:{sys, i, sum}

In:{}
exit [EXIT] 
Out:{}

add.0 [	lengthof %8 = %0 : int[]]
add.1 [	assign %3 = %8  : int]
add.2 [	const %9 = 0 : int]
add.3 [	arraygen %10 = [9; 3] : int[]]
add.4 [	assign %4 = %10  : int[]]
add.5 [	const %11 = 0 : int]
add.6 [	assign %5 = %11  : int]
add.7 [	loop (%0, %1, %5, %6, %7, %12, %13, %14, %15, %16, %17)]
add.8 [	ifge %5, %3 goto blklab0 : int]
add.9 [	indexof %12 = %0, %5 : int[]]
add.10 [	assign %6 = %12  : int]
add.11 [	indexof %13 = %1, %5 : int[]]
add.12 [	assign %7 = %13  : int]
add.13 [	add %14 = %6, %7 : int]
add.14 [	update %0[%5] = %14 : int[] -> int[]]
add.15 [	const %15 = 0 : int]
add.16 [	update %1[%5] = %15 : int[] -> int[]]
add.17 [	const %16 = 1 : int]
add.18 [	add %17 = %5, %16 : int]
add.19 [	assign %5 = %17  : int]
add.20 [.blklab1]
add.21 [.blklab0]
add.22 [	return %0]
add.23 [	return]
main.0 [	const %4 = 0 : int]
main.1 [	const %5 = 10 : int]
main.2 [	arraygen %6 = [4; 5] : int[]]
main.3 [	assign %1 = %6  : int[]]
main.4 [	const %7 = 0 : int]
main.5 [	assign %2 = %7  : int]
main.6 [	loop (%1, %2, %8, %9, %10)]
main.7 [	const %8 = 10 : int]
main.8 [	ifge %2, %8 goto blklab2 : int]
main.9 [	update %1[%2] = %2 : int[] -> int[]]
main.10 [	const %9 = 1 : int]
main.11 [	add %10 = %2, %9 : int]
main.12 [	assign %2 = %10  : int]
main.13 [.blklab3]
main.14 [.blklab2]
main.15 [	invoke (%11) = (%1, %1) ResetMacro4:add : function(int[],int[])->(int[])]
main.16 [	assign %3 = %11  : int[]]
main.17 [	const %12 = 0 : int]
main.18 [	assign %2 = %12  : int]
main.19 [	loop (%2, %13, %14, %15, %16, %17, %18, %19, %20, %21)]
main.20 [	const %13 = 10 : int]
main.21 [	ifge %2, %13 goto blklab4 : int]
main.22 [	fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.23 [	fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.24 [	indexof %16 = %3, %2 : int[]]
main.25 [	indirectinvoke () = %15 (%16) : method(any)->()]
main.26 [	assert]
main.27 [	const %20 = 1 : int]
main.28 [	add %21 = %2, %20 : int]
main.29 [	assign %2 = %21  : int]
main.30 [.blklab5]
main.31 [.blklab4]
main.32 [	return]

Copy elimination analysis completed. File: ResetMacro4.wyil
