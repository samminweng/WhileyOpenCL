WARNING: version numbering unavailable
Parsed 1 source file(s). ....................................................... [63ms+1mb]
Typed 1 source file(s). ........................................................ [80ms+1mb]
Generated code for 1 source file(s). ........................................... [15ms+1mb]
[./ResetMacro3.whiley] applied definite assignment check ............................ [2ms]
[./ResetMacro3.whiley] applied module check ..................................... [2ms+1mb]
[./ResetMacro3.whiley] applied loop variants .................................... [0ms+1mb]
[./ResetMacro3.whiley] applied coercion check ....................................... [1ms]
Whiley => Wyil: compiled 1 file(s) ............................................ [196ms-1mb]
func.0 [	const %4 = 0 : int]
func.1 [	const %5 = 3 : int]
func.2 [	arraygen %6 = [4; 5] : int[]]
func.3 [	assign %3 = %6  : int[]]
func.4 [	const %7 = 10 : int]
func.5 [	ifle %1, %7 goto blklab0 : int]
func.6 [	const %8 = 0 : int]
func.7 [	update %0[%8] = %1 : int[] -> int[]]
func.8 [	return %0]
func.9 [	goto blklab1]
func.10 [.blklab0]
func.11 [	return %3]
func.12 [.blklab1]
func.13 [	return]
main.0 [	const %3 = 2 : int]
main.1 [	const %4 = 3 : int]
main.2 [	arraygen %5 = [3; 4] : int[]]
main.3 [	assign %1 = %5  : int[]]
main.4 [	const %7 = 11 : int]
main.5 [	invoke (%6) = (%1, %7) ResetMacro3:func : function(int[],int)->(int[])]
main.6 [	assign %2 = %6  : int[]]
main.7 [	assign %1 = %2  : int[]]
main.8 [	assert]
main.9 [	fieldload %11 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.10 [	fieldload %12 = %11 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.11 [	const %13 = [120,91,48,93,32,61,32] : int[]]
main.12 [	indirectinvoke () = %12 (%13) : method(int[])->()]
main.13 [	fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.14 [	fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.15 [	const %16 = 0 : int]
main.16 [	indexof %17 = %1, %16 : int[]]
main.17 [	indirectinvoke () = %15 (%17) : method(any)->()]
main.18 [	const %19 = 65536 : int]
main.19 [	invoke (%18) = (%1, %19) ResetMacro3:func : function(int[],int)->(int[])]
main.20 [	assign %1 = %18  : int[]]
main.21 [	assert]
main.22 [	fieldload %23 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.23 [	fieldload %24 = %23 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.24 [	const %25 = [120,91,48,93,32,61,32] : int[]]
main.25 [	indirectinvoke () = %24 (%25) : method(int[])->()]
main.26 [	fieldload %26 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.27 [	fieldload %27 = %26 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.28 [	const %28 = 0 : int]
main.29 [	indexof %29 = %1, %28 : int[]]
main.30 [	indirectinvoke () = %27 (%29) : method(any)->()]
main.31 [	assert]
main.32 [	return]
root->func
root->main
func.0 [	const %4 = 0 : int]
func.1 [	const %5 = 3 : int]
func.2 [	arraygen %6 = [4; 5] : int[]]
func.3 [	assign %3 = %6  : int[]]
func.4 [	const %7 = 10 : int]
func.5 [	ifle %1, %7 goto blklab0 : int]
func.6 [	const %8 = 0 : int]
func.7 [	update %0[%8] = %1 : int[] -> int[]]
func.8 [	return %0]
func.9 [	goto blklab1]
func.10 [.blklab0]
func.11 [	return %3]
func.12 [.blklab1]
func.13 [	return]
main.0 [	const %3 = 2 : int]
main.1 [	const %4 = 3 : int]
main.2 [	arraygen %5 = [3; 4] : int[]]
main.3 [	assign %1 = %5  : int[]]
main.4 [	const %7 = 11 : int]
main.5 [	invoke (%6) = (%1, %7) ResetMacro3:func : function(int[],int)->(int[])]
main.6 [	assign %2 = %6  : int[]]
main.7 [	assign %1 = %2  : int[]]
main.8 [	assert]
main.9 [	fieldload %11 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.10 [	fieldload %12 = %11 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.11 [	const %13 = [120,91,48,93,32,61,32] : int[]]
main.12 [	indirectinvoke () = %12 (%13) : method(int[])->()]
main.13 [	fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.14 [	fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.15 [	const %16 = 0 : int]
main.16 [	indexof %17 = %1, %16 : int[]]
main.17 [	indirectinvoke () = %15 (%17) : method(any)->()]
main.18 [	const %19 = 65536 : int]
main.19 [	invoke (%18) = (%1, %19) ResetMacro3:func : function(int[],int)->(int[])]
main.20 [	assign %1 = %18  : int[]]
main.21 [	assert]
main.22 [	fieldload %23 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.23 [	fieldload %24 = %23 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.24 [	const %25 = [120,91,48,93,32,61,32] : int[]]
main.25 [	indirectinvoke () = %24 (%25) : method(int[])->()]
main.26 [	fieldload %26 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.27 [	fieldload %27 = %26 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.28 [	const %28 = 0 : int]
main.29 [	indexof %29 = %1, %28 : int[]]
main.30 [	indirectinvoke () = %27 (%29) : method(any)->()]
main.31 [	assert]
main.32 [	return]
func.0 [	const %4 = 0 : int]
func.1 [	const %5 = 3 : int]
func.2 [	arraygen %6 = [4; 5] : int[]]
func.3 [	assign %3 = %6  : int[]]
func.4 [	const %7 = 10 : int]
func.5 [	ifle %1, %7 goto blklab0 : int]
func.6 [	const %8 = 0 : int]
func.7 [	update %0[%8] = %1 : int[] -> int[]]
func.8 [	return %0]
func.9 [	goto blklab1]
func.10 [.blklab0]
func.11 [	return %3]
func.12 [.blklab1]
func.13 [	return]
main.0 [	const %3 = 2 : int]
main.1 [	const %4 = 3 : int]
main.2 [	arraygen %5 = [3; 4] : int[]]
main.3 [	assign %1 = %5  : int[]]
main.4 [	const %7 = 11 : int]
main.5 [	invoke (%6) = (%1, %7) ResetMacro3:func : function(int[],int)->(int[])]
main.6 [	assign %2 = %6  : int[]]
main.7 [	assign %1 = %2  : int[]]
main.8 [	assert]
main.9 [	fieldload %11 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.10 [	fieldload %12 = %11 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.11 [	const %13 = [120,91,48,93,32,61,32] : int[]]
main.12 [	indirectinvoke () = %12 (%13) : method(int[])->()]
main.13 [	fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.14 [	fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.15 [	const %16 = 0 : int]
main.16 [	indexof %17 = %1, %16 : int[]]
main.17 [	indirectinvoke () = %15 (%17) : method(any)->()]
main.18 [	const %19 = 65536 : int]
main.19 [	invoke (%18) = (%1, %19) ResetMacro3:func : function(int[],int)->(int[])]
main.20 [	assign %1 = %18  : int[]]
main.21 [	assert]
main.22 [	fieldload %23 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.23 [	fieldload %24 = %23 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.24 [	const %25 = [120,91,48,93,32,61,32] : int[]]
main.25 [	indirectinvoke () = %24 (%25) : method(int[])->()]
main.26 [	fieldload %26 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.27 [	fieldload %27 = %26 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.28 [	const %28 = 0 : int]
main.29 [	indexof %29 = %1, %28 : int[]]
main.30 [	indirectinvoke () = %27 (%29) : method(any)->()]
main.31 [	assert]
main.32 [	return]
###### Live analysis for func function. ######
Iteration 1
In:{[]}
blklab1 [BLOCK] 
Out:{[]}

In:{[1, 3, 7]}
blklab0 [ELSE] 
-------------------------------
l.0:ifle %1, %7 goto blklab0 : int
-------------------------------
Out:{[3]}

In:{[0, 1, 7]}
blklab0 [IF] 
-------------------------------
l.0:ifgt %1, %7 goto blklab0 : int
l.1:const %8 = 0 : int
l.2:update %0[%8] = %1 : int[] -> int[]
-------------------------------
Out:{[0]}

In:{[0, 1, 3, 7]}
blklab0 [CONDITION] 
Out:{[0, 1, 3, 7]}

In:{[0, 1]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 3 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %3 = %6  : int[]
l.4:const %7 = 10 : int
-------------------------------
Out:{[0, 1, 3, 7]}

In:{[0, 1]}
entry [ENTRY] 
Out:{[0, 1]}

###### Live analysis for func function. ######
Iteration 2
In:{[]}
blklab1 [BLOCK] 
Out:{[]}

In:{[1, 3, 7]}
blklab0 [ELSE] 
-------------------------------
l.0:ifle %1, %7 goto blklab0 : int
-------------------------------
Out:{[3]}

In:{[0, 1, 7]}
blklab0 [IF] 
-------------------------------
l.0:ifgt %1, %7 goto blklab0 : int
l.1:const %8 = 0 : int
l.2:update %0[%8] = %1 : int[] -> int[]
-------------------------------
Out:{[0]}

In:{[0, 1, 3, 7]}
blklab0 [CONDITION] 
Out:{[0, 1, 3, 7]}

In:{[0, 1]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 3 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %3 = %6  : int[]
l.4:const %7 = 10 : int
-------------------------------
Out:{[0, 1, 3, 7]}

In:{[0, 1]}
entry [ENTRY] 
Out:{[0, 1]}

###### Live variables for func function. ######
In:{x, num}
entry [ENTRY] 
Out:{x, num}

In:{x, num}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 3 : int
l.2:arraygen %6 = [4; 5] : int[]
l.3:assign %3 = %6  : int[]
l.4:const %7 = 10 : int
-------------------------------
Out:{x, num, a, _7}

In:{x, num, a, _7}
blklab0 [CONDITION] 
Out:{x, num, a, _7}

In:{x, num, _7}
blklab0 [IF] 
-------------------------------
l.0:ifgt %1, %7 goto blklab0 : int
l.1:const %8 = 0 : int
l.2:update %0[%8] = %1 : int[] -> int[]
-------------------------------
Out:{x}

In:{num, a, _7}
blklab0 [ELSE] 
-------------------------------
l.0:ifle %1, %7 goto blklab0 : int
-------------------------------
Out:{a}

In:{x}
return_0 [RETURN] 
-------------------------------
l.0:return %0
-------------------------------
Out:{x}

In:{}
blklab1 [BLOCK] 
Out:{}

In:{a}
return_3 [RETURN] 
-------------------------------
l.0:return %3
-------------------------------
Out:{a}

In:{}
exit [EXIT] 
Out:{}

###### Live analysis for main function. ######
Iteration 1
In:{[]}
blklab4 [BLOCK] 
Out:{[]}

In:{[1]}
blklab4 [ASSERT] 
-------------------------------
l.0:const %30 = 0 : int
l.1:indexof %31 = %1, %30 : int[]
l.2:const %32 = 65536 : int
l.3:ifeq %31, %32 goto blklab4 : int
l.4:fail
l.5:.blklab4
-------------------------------
Out:{[]}

In:{[0, 1]}
blklab3 [BLOCK] 
-------------------------------
l.0:fieldload %23 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.1:fieldload %24 = %23 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.2:const %25 = [120,91,48,93,32,61,32] : int[]
l.3:indirectinvoke () = %24 (%25) : method(int[])->()
l.4:fieldload %26 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.5:fieldload %27 = %26 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.6:const %28 = 0 : int
l.7:indexof %29 = %1, %28 : int[]
l.8:indirectinvoke () = %27 (%29) : method(any)->()
-------------------------------
Out:{[1]}

In:{[0, 1]}
blklab3 [ASSERT] 
-------------------------------
l.0:const %20 = 0 : int
l.1:indexof %21 = %1, %20 : int[]
l.2:const %22 = 65536 : int
l.3:ifeq %21, %22 goto blklab3 : int
l.4:fail
l.5:.blklab3
-------------------------------
Out:{[0, 1]}

In:{[0, 18]}
func20 [BLOCK] 
-------------------------------
l.0:assign %1 = %18  : int[]
-------------------------------
Out:{[0, 1]}

In:{[0, 1, 19]}
func20 [INVOKE] 
-------------------------------
l.0:invoke (%18) = (%1, %19) ResetMacro3:func : function(int[],int)->(int[])
-------------------------------
Out:{[0, 18]}

In:{[0, 1]}
blklab2 [BLOCK] 
-------------------------------
l.0:fieldload %11 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.1:fieldload %12 = %11 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.2:const %13 = [120,91,48,93,32,61,32] : int[]
l.3:indirectinvoke () = %12 (%13) : method(int[])->()
l.4:fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.5:fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.6:const %16 = 0 : int
l.7:indexof %17 = %1, %16 : int[]
l.8:indirectinvoke () = %15 (%17) : method(any)->()
l.9:const %19 = 65536 : int
-------------------------------
Out:{[0, 1, 19]}

In:{[0, 1]}
blklab2 [ASSERT] 
-------------------------------
l.0:const %8 = 0 : int
l.1:indexof %9 = %1, %8 : int[]
l.2:const %10 = 11 : int
l.3:ifeq %9, %10 goto blklab2 : int
l.4:fail
l.5:.blklab2
-------------------------------
Out:{[0, 1]}

In:{[0, 6]}
func6 [BLOCK] 
-------------------------------
l.0:assign %2 = %6  : int[]
l.1:assign %1 = %2  : int[]
-------------------------------
Out:{[0, 1]}

In:{[0, 1, 7]}
func6 [INVOKE] 
-------------------------------
l.0:invoke (%6) = (%1, %7) ResetMacro3:func : function(int[],int)->(int[])
-------------------------------
Out:{[0, 6]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %3 = 2 : int
l.1:const %4 = 3 : int
l.2:arraygen %5 = [3; 4] : int[]
l.3:assign %1 = %5  : int[]
l.4:const %7 = 11 : int
-------------------------------
Out:{[0, 1, 7]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live analysis for main function. ######
Iteration 2
In:{[]}
blklab4 [BLOCK] 
Out:{[]}

In:{[1]}
blklab4 [ASSERT] 
-------------------------------
l.0:const %30 = 0 : int
l.1:indexof %31 = %1, %30 : int[]
l.2:const %32 = 65536 : int
l.3:ifeq %31, %32 goto blklab4 : int
l.4:fail
l.5:.blklab4
-------------------------------
Out:{[]}

In:{[0, 1]}
blklab3 [BLOCK] 
-------------------------------
l.0:fieldload %23 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.1:fieldload %24 = %23 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.2:const %25 = [120,91,48,93,32,61,32] : int[]
l.3:indirectinvoke () = %24 (%25) : method(int[])->()
l.4:fieldload %26 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.5:fieldload %27 = %26 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.6:const %28 = 0 : int
l.7:indexof %29 = %1, %28 : int[]
l.8:indirectinvoke () = %27 (%29) : method(any)->()
-------------------------------
Out:{[1]}

In:{[0, 1]}
blklab3 [ASSERT] 
-------------------------------
l.0:const %20 = 0 : int
l.1:indexof %21 = %1, %20 : int[]
l.2:const %22 = 65536 : int
l.3:ifeq %21, %22 goto blklab3 : int
l.4:fail
l.5:.blklab3
-------------------------------
Out:{[0, 1]}

In:{[0, 18]}
func20 [BLOCK] 
-------------------------------
l.0:assign %1 = %18  : int[]
-------------------------------
Out:{[0, 1]}

In:{[0, 1, 19]}
func20 [INVOKE] 
-------------------------------
l.0:invoke (%18) = (%1, %19) ResetMacro3:func : function(int[],int)->(int[])
-------------------------------
Out:{[0, 18]}

In:{[0, 1]}
blklab2 [BLOCK] 
-------------------------------
l.0:fieldload %11 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.1:fieldload %12 = %11 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.2:const %13 = [120,91,48,93,32,61,32] : int[]
l.3:indirectinvoke () = %12 (%13) : method(int[])->()
l.4:fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.5:fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.6:const %16 = 0 : int
l.7:indexof %17 = %1, %16 : int[]
l.8:indirectinvoke () = %15 (%17) : method(any)->()
l.9:const %19 = 65536 : int
-------------------------------
Out:{[0, 1, 19]}

In:{[0, 1]}
blklab2 [ASSERT] 
-------------------------------
l.0:const %8 = 0 : int
l.1:indexof %9 = %1, %8 : int[]
l.2:const %10 = 11 : int
l.3:ifeq %9, %10 goto blklab2 : int
l.4:fail
l.5:.blklab2
-------------------------------
Out:{[0, 1]}

In:{[0, 6]}
func6 [BLOCK] 
-------------------------------
l.0:assign %2 = %6  : int[]
l.1:assign %1 = %2  : int[]
-------------------------------
Out:{[0, 1]}

In:{[0, 1, 7]}
func6 [INVOKE] 
-------------------------------
l.0:invoke (%6) = (%1, %7) ResetMacro3:func : function(int[],int)->(int[])
-------------------------------
Out:{[0, 6]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %3 = 2 : int
l.1:const %4 = 3 : int
l.2:arraygen %5 = [3; 4] : int[]
l.3:assign %1 = %5  : int[]
l.4:const %7 = 11 : int
-------------------------------
Out:{[0, 1, 7]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live variables for main function. ######
In:{sys}
entry [ENTRY] 
Out:{sys}

In:{sys}
code [BLOCK] 
-------------------------------
l.0:const %3 = 2 : int
l.1:const %4 = 3 : int
l.2:arraygen %5 = [3; 4] : int[]
l.3:assign %1 = %5  : int[]
l.4:const %7 = 11 : int
-------------------------------
Out:{sys, x, _7}

In:{sys, x, _7}
func6 [INVOKE] 
-------------------------------
l.0:invoke (%6) = (%1, %7) ResetMacro3:func : function(int[],int)->(int[])
-------------------------------
Out:{sys, _6}

In:{sys, _6}
func6 [BLOCK] 
-------------------------------
l.0:assign %2 = %6  : int[]
l.1:assign %1 = %2  : int[]
-------------------------------
Out:{sys, x}

In:{sys, x}
blklab2 [ASSERT] 
-------------------------------
l.0:const %8 = 0 : int
l.1:indexof %9 = %1, %8 : int[]
l.2:const %10 = 11 : int
l.3:ifeq %9, %10 goto blklab2 : int
l.4:fail
l.5:.blklab2
-------------------------------
Out:{sys, x}

In:{sys, x}
blklab2 [BLOCK] 
-------------------------------
l.0:fieldload %11 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.1:fieldload %12 = %11 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.2:const %13 = [120,91,48,93,32,61,32] : int[]
l.3:indirectinvoke () = %12 (%13) : method(int[])->()
l.4:fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.5:fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.6:const %16 = 0 : int
l.7:indexof %17 = %1, %16 : int[]
l.8:indirectinvoke () = %15 (%17) : method(any)->()
l.9:const %19 = 65536 : int
-------------------------------
Out:{sys, x, _19}

In:{sys, x, _19}
func20 [INVOKE] 
-------------------------------
l.0:invoke (%18) = (%1, %19) ResetMacro3:func : function(int[],int)->(int[])
-------------------------------
Out:{sys, _18}

In:{sys, _18}
func20 [BLOCK] 
-------------------------------
l.0:assign %1 = %18  : int[]
-------------------------------
Out:{sys, x}

In:{sys, x}
blklab3 [ASSERT] 
-------------------------------
l.0:const %20 = 0 : int
l.1:indexof %21 = %1, %20 : int[]
l.2:const %22 = 65536 : int
l.3:ifeq %21, %22 goto blklab3 : int
l.4:fail
l.5:.blklab3
-------------------------------
Out:{sys, x}

In:{sys, x}
blklab3 [BLOCK] 
-------------------------------
l.0:fieldload %23 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.1:fieldload %24 = %23 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.2:const %25 = [120,91,48,93,32,61,32] : int[]
l.3:indirectinvoke () = %24 (%25) : method(int[])->()
l.4:fieldload %26 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.5:fieldload %27 = %26 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.6:const %28 = 0 : int
l.7:indexof %29 = %1, %28 : int[]
l.8:indirectinvoke () = %27 (%29) : method(any)->()
-------------------------------
Out:{x}

In:{x}
blklab4 [ASSERT] 
-------------------------------
l.0:const %30 = 0 : int
l.1:indexof %31 = %1, %30 : int[]
l.2:const %32 = 65536 : int
l.3:ifeq %31, %32 goto blklab4 : int
l.4:fail
l.5:.blklab4
-------------------------------
Out:{}

In:{}
blklab4 [BLOCK] 
Out:{}

In:{}
exit [EXIT] 
Out:{}

func.0 [	const %4 = 0 : int]
func.1 [	const %5 = 3 : int]
func.2 [	arraygen %6 = [4; 5] : int[]]
func.3 [	assign %3 = %6  : int[]]
func.4 [	const %7 = 10 : int]
func.5 [	ifle %1, %7 goto blklab0 : int]
func.6 [	const %8 = 0 : int]
func.7 [	update %0[%8] = %1 : int[] -> int[]]
func.8 [	return %0]
func.9 [	goto blklab1]
func.10 [.blklab0]
func.11 [	return %3]
func.12 [.blklab1]
func.13 [	return]
main.0 [	const %3 = 2 : int]
main.1 [	const %4 = 3 : int]
main.2 [	arraygen %5 = [3; 4] : int[]]
main.3 [	assign %1 = %5  : int[]]
main.4 [	const %7 = 11 : int]
main.5 [	invoke (%6) = (%1, %7) ResetMacro3:func : function(int[],int)->(int[])]
main.6 [	assign %2 = %6  : int[]]
main.7 [	assign %1 = %2  : int[]]
main.8 [	assert]
main.9 [	fieldload %11 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.10 [	fieldload %12 = %11 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.11 [	const %13 = [120,91,48,93,32,61,32] : int[]]
main.12 [	indirectinvoke () = %12 (%13) : method(int[])->()]
main.13 [	fieldload %14 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.14 [	fieldload %15 = %14 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.15 [	const %16 = 0 : int]
main.16 [	indexof %17 = %1, %16 : int[]]
main.17 [	indirectinvoke () = %15 (%17) : method(any)->()]
main.18 [	const %19 = 65536 : int]
main.19 [	invoke (%18) = (%1, %19) ResetMacro3:func : function(int[],int)->(int[])]
main.20 [	assign %1 = %18  : int[]]
main.21 [	assert]
main.22 [	fieldload %23 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.23 [	fieldload %24 = %23 print_s : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.24 [	const %25 = [120,91,48,93,32,61,32] : int[]]
main.25 [	indirectinvoke () = %24 (%25) : method(int[])->()]
main.26 [	fieldload %26 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.27 [	fieldload %27 = %26 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.28 [	const %28 = 0 : int]
main.29 [	indexof %29 = %1, %28 : int[]]
main.30 [	indirectinvoke () = %27 (%29) : method(any)->()]
main.31 [	assert]
main.32 [	return]

Copy elimination analysis completed. File: ResetMacro3.wyil
