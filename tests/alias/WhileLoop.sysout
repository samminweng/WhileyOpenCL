f.0 [	const %4 = 0 : int]
f.1 [	assign %3 = %4  : int]
f.2 [	assign %1 = %3  : int]
f.3 [	const %6 = 0 : int]
f.4 [	assign %5 = %6  : int]
f.5 [	assign %2 = %5  : int]
f.6 [	loop (%1, %2, %7, %8, %9, %10)]
f.7 [	invariant]
f.8 [	ifge %1, %0 goto blklab1 : int]
f.9 [	add %8 = %2, %1 : int]
f.10 [	assign %2 = %8  : int]
f.11 [	const %9 = 1 : int]
f.12 [	add %10 = %1, %9 : int]
f.13 [	assign %1 = %10  : int]
f.14 [.blklab1]
f.15 [	return %2 : int]
f.16 [	return]
main.0 [	fieldload %1 = %0 out : {[[int]] args,{method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s} out}]
main.1 [	fieldload %2 = %1 println : {method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s}]
main.2 [	const %4 = 5 : int]
main.3 [	invoke %3 = (%4) WhileLoop:f : function(int) -> int]
main.4 [	indirectinvoke %2 (%3) : method(any) -> void]
main.5 [	fieldload %5 = %0 out : {[[int]] args,{method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s} out}]
main.6 [	fieldload %6 = %5 println : {method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s}]
main.7 [	const %8 = 50000 : int]
main.8 [	invoke %7 = (%8) WhileLoop:f : function(int) -> int]
main.9 [	indirectinvoke %6 (%7) : method(any) -> void]
main.10 [	return]
###### Live analysis for f function. ######
In:{limit}
entry [ENTRY] 
Out:{limit}

In:{limit}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:assign %3 = %4  : int
l.2:assign %1 = %3  : int
l.3:const %6 = 0 : int
l.4:assign %5 = %6  : int
l.5:assign %2 = %5  : int
-------------------------------
Out:{limit, i, sum}

In:{limit, i, sum}
blklab1 [LOOP_HEADER] 
-------------------------------
l.0:invariant
-------------------------------
Out:{limit, i, sum}

In:{limit, i, sum}
blklab1 [LOOP_BODY] 
-------------------------------
l.0:ifge %1, %0 goto blklab1 : int
l.1:add %8 = %2, %1 : int
l.2:assign %2 = %8  : int
l.3:const %9 = 1 : int
l.4:add %10 = %1, %9 : int
l.5:assign %1 = %10  : int
-------------------------------
Out:{limit, i, sum}

In:{sum}
blklab1 [LOOP_EXIT] 
-------------------------------
l.0:return %2 : int
-------------------------------
Out:{sum}

In:{}
exit [EXIT] 
Out:{}

###### Live analysis for main function. ######
In:{sys}
entry [ENTRY] 
Out:{sys}

In:{sys}
code [BLOCK] 
-------------------------------
l.0:fieldload %1 = %0 out : {[[int]] args,{method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s} out}
l.1:fieldload %2 = %1 println : {method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s}
l.2:const %4 = 5 : int
l.3:invoke %3 = (%4) WhileLoop:f : function(int) -> int
l.4:indirectinvoke %2 (%3) : method(any) -> void
l.5:fieldload %5 = %0 out : {[[int]] args,{method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s} out}
l.6:fieldload %6 = %5 println : {method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s}
l.7:const %8 = 50000 : int
l.8:invoke %7 = (%8) WhileLoop:f : function(int) -> int
l.9:indirectinvoke %6 (%7) : method(any) -> void
l.10:return
-------------------------------
Out:{}

In:{}
exit [EXIT] 
Out:{}

Alias analysis completed.