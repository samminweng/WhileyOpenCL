swap.0 [	indexof %7 = %0, %1 : [int]]
swap.1 [	assign %6 = %7  : int]
swap.2 [	assign %3 = %6  : int]
swap.3 [	indexof %9 = %0, %2 : [int]]
swap.4 [	assign %8 = %9  : int]
swap.5 [	assign %4 = %8  : int]
swap.6 [	add %11 = %3, %4 : int]
swap.7 [	assign %10 = %11  : int]
swap.8 [	assign %5 = %10  : int]
swap.9 [	update %0[%1] = %4 : [int] -> [int]]
swap.10 [	update %0[%2] = %3 : [int] -> [int]]
swap.11 [	return %0 : [int]]
swap.12 [	return]
main.0 [	const %4 = 0 : int]
main.1 [	const %5 = 2 : int]
main.2 [	const %6 = 1 : int]
main.3 [	const %7 = 3 : int]
main.4 [	const %8 = 4 : int]
main.5 [	newlist %9 = (%4, %5, %6, %7, %8) : [int]]
main.6 [	assign %3 = %9  : [int]]
main.7 [	assign %1 = %3  : [int]]
main.8 [	const %12 = 1 : int]
main.9 [	const %13 = 2 : int]
main.10 [	invoke %11 = (%1, %12, %13) swap:swap : function([int],int,int) -> [int]]
main.11 [	assign %10 = %11  : [int]]
main.12 [	assign %2 = %10  : [int]]
main.13 [	fieldload %14 = %0 out : {[[int]] args,{method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s} out}]
main.14 [	fieldload %15 = %14 println : {method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s}]
main.15 [	indirectinvoke %15 (%2) : method(any) -> void]
main.16 [	return]
###### Live analysis for swap function. ######
Iteration 1
In:{}
exit [EXIT] 
Out:{}

In:{xs, i0, i1}
code [BLOCK] 
-------------------------------
l.0:indexof %7 = %0, %1 : [int]
l.1:assign %6 = %7  : int
l.2:assign %3 = %6  : int
l.3:indexof %9 = %0, %2 : [int]
l.4:assign %8 = %9  : int
l.5:assign %4 = %8  : int
l.6:add %11 = %3, %4 : int
l.7:assign %10 = %11  : int
l.8:assign %5 = %10  : int
l.9:update %0[%1] = %4 : [int] -> [int]
l.10:update %0[%2] = %3 : [int] -> [int]
l.11:return %0 : [int]
-------------------------------
Out:{xs}

In:{xs, i0, i1}
entry [ENTRY] 
Out:{xs, i0, i1}

###### Live analysis for swap function. ######
Iteration 2
In:{}
exit [EXIT] 
Out:{}

In:{xs, i0, i1}
code [BLOCK] 
-------------------------------
l.0:indexof %7 = %0, %1 : [int]
l.1:assign %6 = %7  : int
l.2:assign %3 = %6  : int
l.3:indexof %9 = %0, %2 : [int]
l.4:assign %8 = %9  : int
l.5:assign %4 = %8  : int
l.6:add %11 = %3, %4 : int
l.7:assign %10 = %11  : int
l.8:assign %5 = %10  : int
l.9:update %0[%1] = %4 : [int] -> [int]
l.10:update %0[%2] = %3 : [int] -> [int]
l.11:return %0 : [int]
-------------------------------
Out:{xs}

In:{xs, i0, i1}
entry [ENTRY] 
Out:{xs, i0, i1}

###### Live analysis for swap function. ######
In:{xs, i0, i1}
entry [ENTRY] 
Out:{xs, i0, i1}

In:{xs, i0, i1}
code [BLOCK] 
-------------------------------
l.0:indexof %7 = %0, %1 : [int]
l.1:assign %6 = %7  : int
l.2:assign %3 = %6  : int
l.3:indexof %9 = %0, %2 : [int]
l.4:assign %8 = %9  : int
l.5:assign %4 = %8  : int
l.6:add %11 = %3, %4 : int
l.7:assign %10 = %11  : int
l.8:assign %5 = %10  : int
l.9:update %0[%1] = %4 : [int] -> [int]
l.10:update %0[%2] = %3 : [int] -> [int]
l.11:return %0 : [int]
-------------------------------
Out:{xs}

In:{}
exit [EXIT] 
Out:{}

###### Live analysis for main function. ######
Iteration 1
In:{}
exit [EXIT] 
Out:{}

In:{console}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 2 : int
l.2:const %6 = 1 : int
l.3:const %7 = 3 : int
l.4:const %8 = 4 : int
l.5:newlist %9 = (%4, %5, %6, %7, %8) : [int]
l.6:assign %3 = %9  : [int]
l.7:assign %1 = %3  : [int]
l.8:const %12 = 1 : int
l.9:const %13 = 2 : int
l.10:invoke %11 = (%1, %12, %13) swap:swap : function([int],int,int) -> [int]
l.11:assign %10 = %11  : [int]
l.12:assign %2 = %10  : [int]
l.13:fieldload %14 = %0 out : {[[int]] args,{method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s} out}
l.14:fieldload %15 = %14 println : {method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s}
l.15:indirectinvoke %15 (%2) : method(any) -> void
l.16:return
-------------------------------
Out:{}

In:{console}
entry [ENTRY] 
Out:{console}

###### Live analysis for main function. ######
Iteration 2
In:{}
exit [EXIT] 
Out:{}

In:{console}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 2 : int
l.2:const %6 = 1 : int
l.3:const %7 = 3 : int
l.4:const %8 = 4 : int
l.5:newlist %9 = (%4, %5, %6, %7, %8) : [int]
l.6:assign %3 = %9  : [int]
l.7:assign %1 = %3  : [int]
l.8:const %12 = 1 : int
l.9:const %13 = 2 : int
l.10:invoke %11 = (%1, %12, %13) swap:swap : function([int],int,int) -> [int]
l.11:assign %10 = %11  : [int]
l.12:assign %2 = %10  : [int]
l.13:fieldload %14 = %0 out : {[[int]] args,{method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s} out}
l.14:fieldload %15 = %14 println : {method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s}
l.15:indirectinvoke %15 (%2) : method(any) -> void
l.16:return
-------------------------------
Out:{}

In:{console}
entry [ENTRY] 
Out:{console}

###### Live analysis for main function. ######
In:{console}
entry [ENTRY] 
Out:{console}

In:{console}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:const %5 = 2 : int
l.2:const %6 = 1 : int
l.3:const %7 = 3 : int
l.4:const %8 = 4 : int
l.5:newlist %9 = (%4, %5, %6, %7, %8) : [int]
l.6:assign %3 = %9  : [int]
l.7:assign %1 = %3  : [int]
l.8:const %12 = 1 : int
l.9:const %13 = 2 : int
l.10:invoke %11 = (%1, %12, %13) swap:swap : function([int],int,int) -> [int]
l.11:assign %10 = %11  : [int]
l.12:assign %2 = %10  : [int]
l.13:fieldload %14 = %0 out : {[[int]] args,{method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s} out}
l.14:fieldload %15 = %14 println : {method(any) -> void print,method([int]) -> void print_s,method(any) -> void println,method([int]) -> void println_s}
l.15:indirectinvoke %15 (%2) : method(any) -> void
l.16:return
-------------------------------
Out:{}

In:{}
exit [EXIT] 
Out:{}

Alias analysis completed.