main.0 [	const %3 = 0 : int]
main.1 [	const %4 = 1 : int]
main.2 [	const %5 = 2 : int]
main.3 [	const %6 = 3 : int]
main.4 [	const %7 = 4 : int]
main.5 [	const %8 = 5 : int]
main.6 [	newlist %9 = (%3, %4, %5, %6, %7, %8) : [int]]
main.7 [	invoke %2 = (%9) While_Valid_1:reverse : function([int]) => [int]]
The original pattern:
{
init_before:
	lengthof %3 = %0 : [int]
init:
	assign %1 = %3  : int
list_init:
	const %4 = [] : [void]
	convert %4 = %4 [int] : [void]
init_after:
	assert blklab2
	lengthof %8 = %0 : [int]
	ifle %3, %8 goto blklab2 : int
	fail ""loop invariant not satisfied on entry""
	.blklab2
	assume blklab3
	lengthof %11 = %0 : [int]
	ifle %1, %11 goto blklab3 : int
	fail """"
	.blklab3
	const %13 = 0 : int
loop_header:
	loop (%1, %4)
	ifle %1, %13 goto blklab1 : int
loopbody_before:
	const %15 = 1 : int
loopbody_update:
	sub %16 = %1, %15 : int
	assign %1 = %16  : int
list_update_before:
	assert blklab6
	const %27 = 0 : int
	ifge %16, %27 goto blklab5 : int
	fail ""index out of bounds (negative)""
	.blklab5
	lengthof %28 = %0 : [int]
	iflt %16, %28 goto blklab6 : int
	fail ""index out of bounds (not less than length)""
	.blklab6
list_update:
	indexof %20 = %0, %16 : [int]
	newlist %21 = (%20) : [int]
	append %22 = %4, %21 : [int]
	assign %4 = %22  : [int]
loopbody_after:
	assert blklab4
	lengthof %25 = %0 : [int]
	ifle %16, %25 goto blklab4 : int
	fail ""loop invariant not restored""
	.blklab4
	nop
	end blklab0
loop_exit:
	.blklab1
return:
	return %4 : [int]
}
BuildList && loop_var(%1) && list_var(%4) && decr(%1, 1) && init(%1, 0 + |%0|) && list_init(%4, []) &&  while_cond(%1, >, 0)
=>loop_iters(%1, 0 + |%0|)
From BuildList to BuildListFirst, the transformed pattern:
{
init_before:
	lengthof %3 = %0 : [int]
init:
	assign %1 = %3  : int
list_init:
	lengthof %30 = %0 : [int]
	assign %4 = %0  : [int]
list_size_init:
	const %31 = 0 : int
	assign %32 = %31  : int
init_after:
	assert blklab2
	lengthof %8 = %0 : [int]
	ifle %3, %8 goto blklab2 : int
	fail ""loop invariant not satisfied on entry""
	.blklab2
	assume blklab3
	lengthof %11 = %0 : [int]
	ifle %1, %11 goto blklab3 : int
	fail """"
	.blklab3
	const %13 = 0 : int
loop_header:
	loop (%1, %4, %32)
	ifle %1, %13 goto blklab1 : int
loopbody_before:
	const %15 = 1 : int
loopbody_update:
	sub %16 = %1, %15 : int
	assign %1 = %16  : int
list_update_before:
	assert blklab6
	const %27 = 0 : int
	ifge %16, %27 goto blklab5 : int
	fail ""index out of bounds (negative)""
	.blklab5
	lengthof %28 = %0 : [int]
	iflt %16, %28 goto blklab6 : int
	fail ""index out of bounds (not less than length)""
	.blklab6
	assert blklab7
	const %34 = 0 : int
	ifge %32, %33 goto blklab8 : int
	fail ""index out of bounds (negative)""
	.blklab8
	lengthof %33 = %4 : [int]
	iflt %32, %33 goto blklab7 : int
	fail ""index out of bounds (not less than length)""
	.blklab7
list_update:
	indexof %20 = %0, %16 : [int]
	update %4[%32] = %20 : [int] -> [int]
list_size_update:
	const %35 = 1 : int
	add %36 = %32, %35 : int
	assign %32 = %36  : int
loopbody_after:
	assert blklab4
	lengthof %25 = %0 : [int]
	ifle %16, %25 goto blklab4 : int
	fail ""loop invariant not restored""
	.blklab4
	nop
	end blklab0
loop_exit:
	.blklab1
list_assertion:
	assert blklab9
	ifeq %32, %30 goto blklab9 : int
	fail ""assertion failed""
	.blklab9
return:
	return %4 : [int]
}
BuildListFirst && loop_var(%1) && list_var(%4) && list_size(%32) && list_capacity(%30) &&
decr(%1, 1) && init(%1, 0 + |%0|) && list_init(%4, 0 + %0) && list_size_init(%32, 0 + %31) &&
while_cond(%1, >, 0)
=>loop_iters(%1, 0 + |%0|)
	domain(%3)	= [0..0]
	domain(%4)	= [1..1]
	domain(%5)	= [2..2]
	domain(%6)	= [3..3]
	domain(%7)	= [4..4]
	domain(%8)	= [5..5]
	domain(%9)	= [0..5]
	value(%3)	= 0
	value(%4)	= 1
	value(%5)	= 2
	value(%6)	= 3
	value(%7)	= 4
	value(%8)	= 5
	size(%9)	= 6
Consistency=true
reverse.0 [	lengthof %3 = %0 : [int]]
reverse.1 [	assign %1 = %3  : int]
reverse.2 [	lengthof %30 = %0 : [int]]
reverse.3 [	assign %4 = %0  : [int]]
reverse.4 [	const %31 = 0 : int]
reverse.5 [	assign %32 = %31  : int]
reverse.6 [	assert blklab2]
[30;1mreverse.7 [	lengthof %8 = %0 : [int]][0m
[30;1mreverse.8 [	ifle %3, %8 goto blklab2 : int][0m
[30;1mreverse.9 [	fail ""loop invariant not satisfied on entry""][0m
[30;1mreverse.10 [.blklab2][0m
reverse.11 [	assume blklab3]
[30;1mreverse.12 [	lengthof %11 = %0 : [int]][0m
[30;1mreverse.13 [	ifle %1, %11 goto blklab3 : int][0m
[30;1mreverse.14 [	fail """"][0m
[30;1mreverse.15 [.blklab3][0m
reverse.16 [	const %13 = 0 : int]
reverse.17 [	loop (%1, %4, %32)]
reverse.18 [	ifle %1, %13 goto blklab1 : int]
reverse.19 [	const %15 = 1 : int]
reverse.20 [	sub %16 = %1, %15 : int]
reverse.21 [	assign %1 = %16  : int]
reverse.22 [	assert blklab6]
[30;1mreverse.23 [	const %27 = 0 : int][0m
[30;1mreverse.24 [	ifge %16, %27 goto blklab5 : int][0m
[30;1mreverse.25 [	fail ""index out of bounds (negative)""][0m
[30;1mreverse.26 [.blklab5][0m
[30;1mreverse.27 [	lengthof %28 = %0 : [int]][0m
[30;1mreverse.28 [	iflt %16, %28 goto blklab6 : int][0m
[30;1mreverse.29 [	fail ""index out of bounds (not less than length)""][0m
[30;1mreverse.30 [.blklab6][0m
reverse.31 [	indexof %20 = %0, %16 : [int]]
reverse.32 [	assert blklab7]
[30;1mreverse.33 [	const %34 = 0 : int][0m
[30;1mreverse.34 [	ifge %32, %33 goto blklab8 : int][0m
[30;1mreverse.35 [	fail ""index out of bounds (negative)""][0m
[30;1mreverse.36 [.blklab8][0m
[30;1mreverse.37 [	lengthof %33 = %4 : [int]][0m
[30;1mreverse.38 [	iflt %32, %33 goto blklab7 : int][0m
[30;1mreverse.39 [	fail ""index out of bounds (not less than length)""][0m
[30;1mreverse.40 [.blklab7][0m
reverse.41 [	update %4[%32] = %20 : [int] -> [int]]
reverse.42 [	const %35 = 1 : int]
reverse.43 [	add %36 = %32, %35 : int]
reverse.44 [	assign %32 = %36  : int]
reverse.45 [	assert blklab4]
[30;1mreverse.46 [	lengthof %25 = %0 : [int]][0m
[30;1mreverse.47 [	ifle %16, %25 goto blklab4 : int][0m
[30;1mreverse.48 [	fail ""loop invariant not restored""][0m
[30;1mreverse.49 [.blklab4][0m
reverse.50 [	nop]
reverse.51 [end blklab0]
reverse.52 [.blklab1]
reverse.53 [	assert blklab9]
[30;1mreverse.54 [	ifeq %32, %30 goto blklab9 : int][0m
[30;1mreverse.55 [	fail ""assertion failed""][0m
[30;1mreverse.56 [.blklab9][0m
reverse.57 [	return %4 : [int]]
	domain(%0)	= [0..5]
	domain(%1)	= [0..6]
	domain(%3)	= [6..6]
	domain(%4)	= [0..5]
	domain(%8)	= [6..6]
	domain(%11)	= [6..6]
	domain(%13)	= [0..0]
	domain(%15)	= [-1..-1]
	domain(%16)	= [0..5]
	domain(%25)	= [6..6]
	domain(%27)	= [0..0]
	domain(%28)	= [6..6]
	domain(%30)	= [0..6]
	domain(%31)	= [0..0]
	domain(%32)	= [0..6]
	domain(%33)	= [6..6]
	domain(%34)	= [0..0]
	domain(%35)	= [1..1]
	domain(%36)	= [1..6]
	domain(return)	= [0..5]
	value(%3)	= 6
	value(%8)	= 6
	value(%11)	= 6
	value(%13)	= 0
	value(%15)	= 1
	value(%25)	= 6
	value(%27)	= 0
	value(%28)	= 6
	value(%30)	= 6
	value(%31)	= 0
	value(%33)	= 6
	value(%34)	= 0
	value(%35)	= 1
	size(%0)	= 6
	size(%4)	= 6
	size(return)	= 6
Consistency=true
main.8 [	assign %1 = %2  : [int]]
main.9 [	fieldload %11 = %0 out : {[string] args,{method(any) => void print,method(any) => void println} out}]
main.10 [	fieldload %12 = %11 println : {method(any) => void print,method(any) => void println}]
main.11 [	assign %14 = %1  : [int]]
main.12 [	convert %14 = %14 any : [int]]
main.13 [	invoke %13 = (%14) whiley/lang/Any:toString : function(any) => string]
main.14 [	convert %13 = %13 any : string]
main.15 [	indirectinvoke %12 (%13) : method(any) => void]
main.16 [	return]
	domain(%1)	= [0..5]
	domain(%2)	= [0..5]
	domain(%3)	= [0..0]
	domain(%4)	= [1..1]
	domain(%5)	= [2..2]
	domain(%6)	= [3..3]
	domain(%7)	= [4..4]
	domain(%8)	= [5..5]
	domain(%9)	= [0..5]
	domain(%14)	= [0..5]
	value(%3)	= 0
	value(%4)	= 1
	value(%5)	= 2
	value(%6)	= 3
	value(%7)	= 4
	value(%8)	= 5
	size(%1)	= 6
	size(%2)	= 6
	size(%9)	= 6
Consistency=true
Bound analysis completed.