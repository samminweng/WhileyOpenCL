void main([string] args, {method(any) => void print,method(any) => void println} out)
main.0 [	const %3 = 1 : int]
main.1 [	const %4 = 2 : int]
main.2 [	const %5 = 3 : int]
main.3 [	const %6 = 4 : int]
main.4 [	const %7 = 5 : int]
main.5 [	newlist %8 = (%3, %4, %5, %6, %7) : [int]]
main.6 [	invoke %2 = (%8) While_Valid_1:reverse : function([int]) => [int]]
Bounds at the 6th line number of function main:
	domain(%3)	= [1..1]
	domain(%4)	= [2..2]
	domain(%5)	= [3..3]
	domain(%6)	= [4..4]
	domain(%7)	= [5..5]
	domain(%8)	= [1..5]
	value(%3)	= 1
	value(%4)	= 2
	value(%5)	= 3
	value(%6)	= 4
	value(%7)	= 5
	size(%8)	= 5
Consistency=true
[int] reverse([int] %0)
reverse.0 [	lengthof %3 = %0 : [int]]
reverse.1 [	assign %1 = %3  : int]
reverse.2 [	const %4 = [] : [void]]
reverse.3 [	convert %4 = %4 [int] : [void]]
reverse.4 [	assert blklab2]
[30;1mreverse.5 [	lengthof %8 = %0 : [int]][0m
[30;1mreverse.6 [	ifle %3, %8 goto blklab2 : int][0m
[30;1mreverse.7 [	fail ""loop invariant not satisfied on entry""][0m
[30;1mreverse.8 [.blklab2][0m
reverse.9 [	loop (%1, %4)]
reverse.10 [	assume blklab3]
[30;1mreverse.11 [	lengthof %11 = %0 : [int]][0m
[30;1mreverse.12 [	ifle %1, %11 goto blklab3 : int][0m
[30;1mreverse.13 [	fail """"][0m
[30;1mreverse.14 [.blklab3][0m
reverse.15 [	const %13 = 0 : int]
reverse.16 [	ifle %1, %13 goto blklab1 : int]
reverse.17 [	const %15 = 1 : int]
reverse.18 [	sub %16 = %1, %15 : int]
reverse.19 [	assign %1 = %16  : int]
reverse.20 [	assert blklab6]
[30;1mreverse.21 [	const %27 = 0 : int][0m
[30;1mreverse.22 [	ifge %16, %27 goto blklab5 : int][0m
[30;1mreverse.23 [	fail ""index out of bounds (negative)""][0m
[30;1mreverse.24 [.blklab5][0m
[30;1mreverse.25 [	lengthof %28 = %0 : [int]][0m
[30;1mreverse.26 [	iflt %16, %28 goto blklab6 : int][0m
[30;1mreverse.27 [	fail ""index out of bounds (not less than length)""][0m
[30;1mreverse.28 [.blklab6][0m
reverse.29 [	indexof %20 = %0, %16 : [int]]
reverse.30 [	newlist %21 = (%20) : [int]]
reverse.31 [	append %22 = %4, %21 : [int]]
reverse.32 [	assign %4 = %22  : [int]]
reverse.33 [	assert blklab4]
[30;1mreverse.34 [	lengthof %25 = %0 : [int]][0m
[30;1mreverse.35 [	ifle %16, %25 goto blklab4 : int][0m
[30;1mreverse.36 [	fail ""loop invariant not restored""][0m
[30;1mreverse.37 [.blklab4][0m
reverse.38 [	nop]
reverse.39 [end blklab0]
reverse.40 [.blklab1]
reverse.41 [	return %4 : [int]]
Bounds at the end of function reverse:
	domain(%0)	= [1..5]
	domain(%1)	= [0..5]
	domain(%3)	= [5..5]
	domain(%4)	= [1..5]
	domain(%13)	= [0..0]
	domain(%15)	= [-5..3]
	domain(%16)	= [0..4]
	domain(%21)	= [1..5]
	domain(%22)	= [1..5]
	domain(return)	= [1..5]
	value(%3)	= 5
	value(%4)	= []
	value(%13)	= 0
	value(%15)	= 1
	size(%0)	= 5
	size(%4)	= 1
	size(%21)	= 1
	size(%22)	= 1
	size(return)	= 1
Consistency=true
main.7 [	assign %1 = %2  : [int]]
main.8 [	fieldload %10 = %0 out : {[string] args,{method(any) => void print,method(any) => void println} out}]
main.9 [	fieldload %11 = %10 println : {method(any) => void print,method(any) => void println}]
main.10 [	assign %13 = %1  : [int]]
main.11 [	convert %13 = %13 any : [int]]
main.12 [	invoke %12 = (%13) whiley/lang/Any:toString : function(any) => string]
main.13 [	convert %12 = %12 any : string]
main.14 [	indirectinvoke %11 (%12) : method(any) => void]
main.15 [	return]
Bounds at the end of function main:
	domain(%1)	= [1..5]
	domain(%2)	= [1..5]
	domain(%3)	= [1..1]
	domain(%4)	= [2..2]
	domain(%5)	= [3..3]
	domain(%6)	= [4..4]
	domain(%7)	= [5..5]
	domain(%8)	= [1..5]
	domain(%13)	= [1..5]
	value(%3)	= 1
	value(%4)	= 2
	value(%5)	= 3
	value(%6)	= 4
	value(%7)	= 5
	size(%1)	= 1
	size(%2)	= 1
	size(%8)	= 5
Consistency=true
