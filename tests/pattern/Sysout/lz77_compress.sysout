WARNING: version numbering unavailable
f.0 [	const %4 = 0 : int]
f.1 [	assign %2 = %4  : int]
f.2 [	const %5 = 0 : int]
f.3 [	assign %3 = %5  : int]
f.4 [	loop (%2, %3, %6, %7, %8, %9)]
f.5 [	invariant]
f.6 [	ifge %2, %0 goto blklab1 : int]
f.7 [	add %7 = %3, %2 : int]
f.8 [	assign %3 = %7  : int]
f.9 [	const %8 = 1 : int]
f.10 [	add %9 = %2, %8 : int]
f.11 [	assign %2 = %9  : int]
f.12 [.blklab2]
f.13 [.blklab1]
f.14 [	return %3]
f.15 [	return]
main.0 [	const %4 = 43 : int]
main.1 [	invoke (%3) = (%4) whileloop:f : function(int)->(int)]
main.2 [	assign %1 = %3  : int]
main.3 [	fieldload %5 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.4 [	fieldload %6 = %5 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.5 [	indirectinvoke () = %6 (%1) : method(any)->()]
main.6 [	assert]
main.7 [	const %9 = 65536 : int]
main.8 [	invoke (%8) = (%9) whileloop:f : function(int)->(int)]
main.9 [	assign %2 = %8  : int]
main.10 [	fieldload %10 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}]
main.11 [	fieldload %11 = %10 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}]
main.12 [	indirectinvoke () = %11 (%2) : method(any)->()]
main.13 [	assert]
main.14 [	return]
###### Live analysis for f function. ######
Iteration 1
In:{[]}
blklab2 [BLOCK] 
Out:{[]}

In:{[3]}
blklab1 [LOOP_EXIT] 
Out:{[3]}

In:{[0, 2, 3]}
blklab1 [LOOP_BODY] 
-------------------------------
l.0:ifge %2, %0 goto blklab1 : int
l.1:add %7 = %3, %2 : int
l.2:assign %3 = %7  : int
l.3:const %8 = 1 : int
l.4:add %9 = %2, %8 : int
l.5:assign %2 = %9  : int
-------------------------------
Out:{[]}

In:{[0, 2, 3]}
blklab1 [LOOP_HEADER] 
Out:{[0, 2, 3]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:assign %2 = %4  : int
l.2:const %5 = 0 : int
l.3:assign %3 = %5  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live analysis for f function. ######
Iteration 2
In:{[0, 2, 3]}
blklab2 [BLOCK] 
Out:{[0, 2, 3]}

In:{[3]}
blklab1 [LOOP_EXIT] 
Out:{[3]}

In:{[0, 2, 3]}
blklab1 [LOOP_BODY] 
-------------------------------
l.0:ifge %2, %0 goto blklab1 : int
l.1:add %7 = %3, %2 : int
l.2:assign %3 = %7  : int
l.3:const %8 = 1 : int
l.4:add %9 = %2, %8 : int
l.5:assign %2 = %9  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0, 2, 3]}
blklab1 [LOOP_HEADER] 
Out:{[0, 2, 3]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:assign %2 = %4  : int
l.2:const %5 = 0 : int
l.3:assign %3 = %5  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live analysis for f function. ######
Iteration 3
In:{[0, 2, 3]}
blklab2 [BLOCK] 
Out:{[0, 2, 3]}

In:{[3]}
blklab1 [LOOP_EXIT] 
Out:{[3]}

In:{[0, 2, 3]}
blklab1 [LOOP_BODY] 
-------------------------------
l.0:ifge %2, %0 goto blklab1 : int
l.1:add %7 = %3, %2 : int
l.2:assign %3 = %7  : int
l.3:const %8 = 1 : int
l.4:add %9 = %2, %8 : int
l.5:assign %2 = %9  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0, 2, 3]}
blklab1 [LOOP_HEADER] 
Out:{[0, 2, 3]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:assign %2 = %4  : int
l.2:const %5 = 0 : int
l.3:assign %3 = %5  : int
-------------------------------
Out:{[0, 2, 3]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live variables for f function. ######
In:{limit}
entry [ENTRY] 
Out:{limit}

In:{limit}
code [BLOCK] 
-------------------------------
l.0:const %4 = 0 : int
l.1:assign %2 = %4  : int
l.2:const %5 = 0 : int
l.3:assign %3 = %5  : int
-------------------------------
Out:{limit, i, sum}

In:{limit, i, sum}
blklab1 [LOOP_HEADER] 
Out:{limit, i, sum}

In:{limit, i, sum}
blklab1 [LOOP_BODY] 
-------------------------------
l.0:ifge %2, %0 goto blklab1 : int
l.1:add %7 = %3, %2 : int
l.2:assign %3 = %7  : int
l.3:const %8 = 1 : int
l.4:add %9 = %2, %8 : int
l.5:assign %2 = %9  : int
-------------------------------
Out:{limit, i, sum}

In:{sum}
blklab1 [LOOP_EXIT] 
Out:{sum}

In:{limit, i, sum}
blklab2 [BLOCK] 
Out:{limit, i, sum}

In:{sum}
return_3 [RETURN] 
-------------------------------
l.0:return %3
-------------------------------
Out:{sum}

In:{}
exit [EXIT] 
Out:{}

###### Live analysis for main function. ######
Iteration 1
In:{[0, 8]}
f9 [BLOCK] 
-------------------------------
l.0:assign %2 = %8  : int
l.1:fieldload %10 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %11 = %10 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %11 (%2) : method(any)->()
-------------------------------
Out:{[]}

In:{[0, 9]}
f9 [INVOKE] 
-------------------------------
l.0:invoke (%8) = (%9) whileloop:f : function(int)->(int)
-------------------------------
Out:{[0, 8]}

In:{[0, 3]}
f2 [BLOCK] 
-------------------------------
l.0:assign %1 = %3  : int
l.1:fieldload %5 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %6 = %5 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %6 (%1) : method(any)->()
l.4:const %9 = 65536 : int
-------------------------------
Out:{[0, 9]}

In:{[0, 4]}
f2 [INVOKE] 
-------------------------------
l.0:invoke (%3) = (%4) whileloop:f : function(int)->(int)
-------------------------------
Out:{[0, 3]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 43 : int
-------------------------------
Out:{[0, 4]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live analysis for main function. ######
Iteration 2
In:{[0, 8]}
f9 [BLOCK] 
-------------------------------
l.0:assign %2 = %8  : int
l.1:fieldload %10 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %11 = %10 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %11 (%2) : method(any)->()
-------------------------------
Out:{[]}

In:{[0, 9]}
f9 [INVOKE] 
-------------------------------
l.0:invoke (%8) = (%9) whileloop:f : function(int)->(int)
-------------------------------
Out:{[0, 8]}

In:{[0, 3]}
f2 [BLOCK] 
-------------------------------
l.0:assign %1 = %3  : int
l.1:fieldload %5 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %6 = %5 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %6 (%1) : method(any)->()
l.4:const %9 = 65536 : int
-------------------------------
Out:{[0, 9]}

In:{[0, 4]}
f2 [INVOKE] 
-------------------------------
l.0:invoke (%3) = (%4) whileloop:f : function(int)->(int)
-------------------------------
Out:{[0, 3]}

In:{[0]}
code [BLOCK] 
-------------------------------
l.0:const %4 = 43 : int
-------------------------------
Out:{[0, 4]}

In:{[0]}
entry [ENTRY] 
Out:{[0]}

###### Live variables for main function. ######
In:{sys}
entry [ENTRY] 
Out:{sys}

In:{sys}
code [BLOCK] 
-------------------------------
l.0:const %4 = 43 : int
-------------------------------
Out:{sys, _4}

In:{sys, _4}
f2 [INVOKE] 
-------------------------------
l.0:invoke (%3) = (%4) whileloop:f : function(int)->(int)
-------------------------------
Out:{sys, _3}

In:{sys, _3}
f2 [BLOCK] 
-------------------------------
l.0:assign %1 = %3  : int
l.1:fieldload %5 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %6 = %5 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %6 (%1) : method(any)->()
l.4:const %9 = 65536 : int
-------------------------------
Out:{sys, _9}

In:{sys, _9}
f9 [INVOKE] 
-------------------------------
l.0:invoke (%8) = (%9) whileloop:f : function(int)->(int)
-------------------------------
Out:{sys, _8}

In:{sys, _8}
f9 [BLOCK] 
-------------------------------
l.0:assign %2 = %8  : int
l.1:fieldload %10 = %0 out : {int[][] args,{method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s} out}
l.2:fieldload %11 = %10 println : {method(any)->() print,method(int[])->() print_s,method(any)->() println,method(int[])->() println_s}
l.3:indirectinvoke () = %11 (%2) : method(any)->()
-------------------------------
Out:{}

In:{}
exit [EXIT] 
Out:{}

=== Bound Analysis on main function ===
=================================

Bound Analysis of 'main' function:
	domain(_4)	=[43..43]
Consistency=true

=================================
=================================

Bound Analysis of 'f' function:
	domain(limit)	=[43..43]
	domain(i)	=[0..43]
	domain(sum)	=[0..infinity]
	domain(_4)	=[0..0]
	domain(_5)	=[0..0]
	domain(_7)	=[0..infinity]
	domain(_8)	=[1..1]
	domain(_9)	=[1..43]
	domain(return)	=[0..infinity]
Consistency=true

=================================
=================================

Bound Analysis of 'main' function:
	domain(a)	=[0..infinity]
	domain(_3)	=[0..infinity]
	domain(_4)	=[43..43]
	domain(_9)	=[65536..65536]
Consistency=true

=================================
=================================

Bound Analysis of 'f' function:
	domain(limit)	=[65536..65536]
	domain(i)	=[0..65536]
	domain(sum)	=[0..infinity]
	domain(_4)	=[0..0]
	domain(_5)	=[0..0]
	domain(_7)	=[0..infinity]
	domain(_8)	=[1..1]
	domain(_9)	=[1..65536]
	domain(return)	=[0..infinity]
Consistency=true

=================================
=================================

Bound Analysis of 'main' function:
	domain(a)	=[0..infinity]
	domain(b)	=[0..infinity]
	domain(_3)	=[0..infinity]
	domain(_4)	=[43..43]
	domain(_8)	=[0..infinity]
	domain(_9)	=[65536..65536]
Consistency=true

=================================
Final bounds of f :
=================================

Bound Analysis of 'f' function:
	domain(limit)	=[43..65536]
	domain(i)	=[0..65536]
	domain(sum)	=[0..infinity]
	domain(_4)	=[0..0]
	domain(_5)	=[0..0]
	domain(_7)	=[0..infinity]
	domain(_8)	=[1..1]
	domain(_9)	=[1..65536]
	domain(return)	=[0..infinity]
Consistency=true

=================================
Final bounds of main :
=================================

Bound Analysis of 'main' function:
	domain(a)	=[0..infinity]
	domain(b)	=[0..infinity]
	domain(_3)	=[0..infinity]
	domain(_4)	=[43..43]
	domain(_8)	=[0..infinity]
	domain(_9)	=[65536..65536]
Consistency=true

=================================

Bound analysis completed. File: whileloop
Code Generation completed. File: whileloop.c, whileloop.h
